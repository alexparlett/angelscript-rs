WHITESPACE = _{ " " | "\t" | "\n" | "\r" | "\u{FEFF}" }
COMMENT = _{ ("//" ~ (!"\n" ~ ANY)*) | ("/*" ~ (!"*/" ~ ANY)* ~ "*/") }

// Main script structure
SCRIPT = { SOI ~ (INCLUDE | IMPORT | ENUM | TYPEDEF | CLASS | MIXIN | INTERFACE | FUNCDEF | VIRTPROP | VAR | FUNC | NAMESPACE | USING | ";")* ~ EOI }

INCLUDE = { "#include" ~ STRING }

IMPORT = { "import" ~ TYPE ~ "&"? ~ IDENTIFIER ~ PARAMLIST ~ FUNCATTR ~ "from" ~ STRING ~ ";" }

USING = { "using" ~ "namespace" ~ IDENTIFIER ~ ("::" ~ IDENTIFIER)* ~ ";" }

NAMESPACE = { "namespace" ~ IDENTIFIER ~ ("::" ~ IDENTIFIER)* ~ "{" ~ SCRIPT ~ "}" }

ENUM = { ("shared" | "external")* ~ "enum" ~ IDENTIFIER ~ (";" | ("{" ~ IDENTIFIER ~ ("=" ~ EXPR)? ~ ("," ~ IDENTIFIER ~ ("=" ~ EXPR)?)* ~ "}")) }

FUNCDEF = { ("external" | "shared")* ~ "funcdef" ~ TYPE ~ "&"? ~ IDENTIFIER ~ PARAMLIST ~ ";" }

FUNC = { ("shared" | "external")* ~ ("private" | "protected")? ~ ((TYPE ~ "&"?) | "~")? ~ IDENTIFIER ~ PARAMLIST ~ "const"? ~ FUNCATTR ~ (";" | STATBLOCK) }

VIRTPROP = { ("private" | "protected")? ~ TYPE ~ "&"? ~ IDENTIFIER ~ "{" ~ (("get" | "set") ~ "const"? ~ FUNCATTR ~ (STATBLOCK | ";"))* ~ "}" }

INTERFACE = { ("external" | "shared")* ~ "interface" ~ IDENTIFIER ~ (";" | ((":" ~ IDENTIFIER ~ ("," ~ IDENTIFIER)*)? ~ "{" ~ (VIRTPROP | INTFMTHD)* ~ "}")) }

MIXIN = { "mixin" ~ CLASS }

CLASS = { ("shared" | "abstract" | "final" | "external")* ~ "class" ~ IDENTIFIER ~ (";" | ((":" ~ IDENTIFIER ~ ("," ~ IDENTIFIER)*)? ~ "{" ~ (VIRTPROP | FUNC | VAR | FUNCDEF)* ~ "}")) }

VAR = { ("private" | "protected")? ~ TYPE ~ IDENTIFIER ~ (("=" ~ (INITLIST | EXPR)) | ARGLIST)? ~ ("," ~ IDENTIFIER ~ (("=" ~ (INITLIST | EXPR)) | ARGLIST)?)* ~ ";" }

TYPEDEF = { "typedef" ~ PRIMTYPE ~ IDENTIFIER ~ ";" }

INTFMTHD = { TYPE ~ "&"? ~ IDENTIFIER ~ PARAMLIST ~ "const"? ~ ";" }

STATBLOCK = { "{" ~ (VAR | STATEMENT | USING)* ~ "}" }

PARAMLIST = { "(" ~ ("void" | (TYPE ~ TYPEMOD ~ ("..." | (IDENTIFIER? ~ ("=" ~ EXPR)?)) ~ ("," ~ TYPE ~ TYPEMOD ~ ("..." | (IDENTIFIER? ~ ("=" ~ EXPR)?)))*)?)? ~ ")" }

TYPEMOD = { ("&" ~ ("in" | "out" | "inout")?)? }

TYPE = { "const"? ~ SCOPE ~ DATATYPE ~ TEMPLTYPELIST? ~ ( ("[" ~ "]") | ("@" ~ "const"?) )* }

TEMPLTYPELIST = { "<" ~ TYPE ~ ("," ~ TYPE)* ~ ">" }

INITLIST = { "{" ~ (ASSIGN | INITLIST)? ~ ("," ~ (ASSIGN | INITLIST)?)* ~ "}" }

SCOPE = { "::"? ~ (IDENTIFIER ~ "::")* ~ (IDENTIFIER ~ TEMPLTYPELIST? ~ "::")? }

DATATYPE = { IDENTIFIER | PRIMTYPE | "?" | "auto" }

PRIMTYPE = { "void" | "int8" | "int16" | "int32" | "int64" | "uint8" | "uint16" | "uint32" | "uint64" | "int" | "uint" | "float" | "double" | "bool" }

FUNCATTR = { ("override" | "final" | "explicit" | "property" | "delete")* }

// Statements
STATEMENT = { IF | FOR | FOREACH | WHILE | RETURN | STATBLOCK | BREAK | CONTINUE | DOWHILE | SWITCH | EXPRSTAT | TRY }

EXPRSTAT = { ASSIGN? ~ ";" }

SWITCH = { "switch" ~ "(" ~ ASSIGN ~ ")" ~ "{" ~ CASE* ~ "}" }

IF = { "if" ~ "(" ~ ASSIGN ~ ")" ~ STATEMENT ~ ("else" ~ STATEMENT)? }

TRY = { "try" ~ STATBLOCK ~ "catch" ~ STATBLOCK }

FOR = { "for" ~ "(" ~ (VAR | EXPRSTAT) ~ EXPRSTAT ~ (ASSIGN ~ ("," ~ ASSIGN)*)? ~ ")" ~ STATEMENT }

FOREACH = { "foreach" ~ "(" ~ TYPE ~ IDENTIFIER ~ ("," ~ TYPE ~ IDENTIFIER)* ~ ":" ~ ASSIGN ~ ")" ~ STATEMENT }

WHILE = { "while" ~ "(" ~ ASSIGN ~ ")" ~ STATEMENT }

DOWHILE = { "do" ~ STATEMENT ~ "while" ~ "(" ~ ASSIGN ~ ")" ~ ";" }

RETURN = { "return" ~ ASSIGN? ~ ";" }

BREAK = { "break" ~ ";" }

CONTINUE = { "continue" ~ ";" }

CASE = { (("case" ~ EXPR) | "default") ~ ":" ~ STATEMENT* }

// Expressions
EXPR = { EXPRTERM ~ (EXPROP ~ EXPRTERM)* }

EXPRTERM = { ((TYPE ~ "=")? ~ INITLIST) | (EXPRPREOP* ~ EXPRVALUE ~ EXPRPOSTOP*) }

EXPRVALUE = { "void" | CONSTRUCTCALL | FUNCCALL | VARACCESS | CAST | LITERAL | ("(" ~ ASSIGN ~ ")") | LAMBDA }

CONSTRUCTCALL = { TYPE ~ ARGLIST }

EXPRPREOP = { "-" | "+" | "!" | "++" | "--" | "~" | "@" }

EXPRPOSTOP = { ("." ~ (FUNCCALL | IDENTIFIER)) | ("[" ~ (IDENTIFIER ~ ":")? ~ ASSIGN ~ ("," ~ (IDENTIFIER ~ ":")? ~ ASSIGN)* ~ "]") | ARGLIST | "++" | "--" }

CAST = { "cast" ~ "<" ~ TYPE ~ ">" ~ "(" ~ ASSIGN ~ ")" }

LITERAL = { NUMBER | STRING | BITS | "true" | "false" | "null" }

LAMBDA = { "function" ~ "(" ~ ((TYPE ~ TYPEMOD)? ~ IDENTIFIER? ~ ("," ~ (TYPE ~ TYPEMOD)? ~ IDENTIFIER?)*)? ~ ")" ~ STATBLOCK }

FUNCCALL = { SCOPE ~ IDENTIFIER ~ TEMPLTYPELIST? ~ ARGLIST }

VARACCESS = { SCOPE ~ IDENTIFIER }

ARGLIST = { "(" ~ ((IDENTIFIER ~ ":")? ~ ASSIGN ~ ("," ~ (IDENTIFIER ~ ":")? ~ ASSIGN)*)? ~ ")" }

ASSIGN = { "@"? ~ CONDITION ~ (ASSIGNOP ~ ASSIGN)? }

CONDITION = { EXPR ~ ("?" ~ ASSIGN ~ ":" ~ ASSIGN)? }

// Operators
EXPROP = { MATHOP | COMPOP | LOGICOP | BITOP }

MATHOP = { "**" | "+" | "-" | "*" | "/" | "%" }

COMPOP = { "==" | "!=" | "<=" | ">=" | "<" | ">" | "!is" | "is" }

LOGICOP = { "&&" | "||" | "^^" | "and" | "or" | "xor" }

BITOP = { ">>>" | "<<" | ">>" | "&" | "|" | "^" }

ASSIGNOP = { "**=" | ">>>=" | "<<=" | ">>=" | "+=" | "-=" | "*=" | "/=" | "|=" | "&=" | "^=" | "%=" | "=" }

// Lexical tokens (atomic rules)
IDENTIFIER = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

NUMBER = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }

STRING = @{ 
    ("\"" ~ (("\\" ~ ANY) | (!("\"" | "\r" | "\n") ~ ANY))* ~ "\"") |
    ("'" ~ (("\\" ~ ANY) | (!("'" | "\r" | "\n") ~ ANY))* ~ "'")
}

BITS = @{ "0" ~ ("b" | "B" | "o" | "O" | "d" | "D" | "x" | "X") ~ (ASCII_DIGIT | 'a'..'f' | 'A'..'F')+ }
