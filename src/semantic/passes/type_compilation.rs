//! Pass 2a: Type Compilation - Fill in all type details and resolve type expressions.
//!
//! This module implements the second pass of semantic analysis which takes the Registry
//! from Pass 1 (with registered names as empty shells) and fills in all type details.
//!
//! # What Pass 2a Does
//!
//! - Resolve all TypeExpr AST nodes → DataType
//! - Fill in class details (fields, methods, inheritance)
//! - Instantiate template types with caching
//! - Register complete function signatures
//! - Build type hierarchy (inheritance, interfaces)
//!
//! # What Pass 2a Does NOT Do
//!
//! - Does NOT track local variables (that's Pass 2b)
//! - Does NOT type check function bodies (that's Pass 2b)
//! - Does NOT generate bytecode (that's Pass 2b)
//!
//! # Example
//!
//! ```ignore
//! use angelscript::{Parser::parse_lenient, Registrar, TypeCompiler};
//! use bumpalo::Bump;
//!
//! let arena = Bump::new();
//! let source = r#"
//!     class Player {
//!         int health;
//!         array<string> items;
//!     }
//! "#;
//! let (script, _) = Parser::parse_lenient(source, &arena);
//!
//! // Pass 1: Registration
//! let registration = Registrar::register(&script);
//!
//! // Pass 2a: Type compilation
//! let type_compilation = TypeCompiler::compile(&script, registration.registry);
//! assert!(type_compilation.errors.is_empty());
//! ```

use crate::semantic::error::{SemanticError, SemanticErrorKind};
use crate::semantic::types::{
    data_type::{DataType, RefModifier},
    registry::Registry,
    type_def::{AutoGeneratedMethod, FieldDef, FunctionId, FunctionTraits, MethodSignature, OperatorBehavior, TypeDef, TypeId, Visibility},
};
use crate::semantic::{INT32_TYPE, FLOAT_TYPE, DOUBLE_TYPE, STRING_TYPE, BOOL_TYPE};
use crate::ast::decl::{
    ClassDecl, ClassMember, EnumDecl, FuncdefDecl, FunctionDecl, GlobalVarDecl,
    InterfaceDecl, InterfaceMethod, Item, NamespaceDecl, TypedefDecl, UsingNamespaceDecl,
};
use crate::ast::expr::{Expr, InitElement};
use crate::ast::stmt::{Block, Stmt, ForInit};
use crate::ast::types::{ParamType, PrimitiveType, TypeBase, TypeExpr, TypeSuffix};
use crate::ast::RefKind;
use crate::ast::Script;
use crate::lexer::Span;
use rustc_hash::{FxHashMap, FxHashSet};

/// Output from Pass 2a: Type Compilation
#[derive(Debug)]
pub struct TypeCompilationData<'ast> {
    /// Registry with complete type information
    pub registry: Registry<'ast>,

    /// Maps AST TypeExpr spans to resolved DataType
    pub type_map: FxHashMap<Span, DataType>,

    /// Errors found during type compilation
    pub errors: Vec<SemanticError>,
}

/// Pass 2a: Type Compilation visitor
///
/// Walks the AST and fills in all type details in the Registry.
pub struct TypeCompiler<'ast> {
    /// The registry we're filling in
    registry: Registry<'ast>,

    /// Maps AST spans to resolved types
    type_map: FxHashMap<Span, DataType>,

    /// Current namespace path (e.g., ["Game", "World"])
    namespace_path: Vec<String>,

    /// Imported namespace paths from `using namespace` directives (fully qualified)
    imported_namespaces: Vec<String>,

    /// Errors found during compilation
    errors: Vec<SemanticError>,

    /// Phantom markers
    _phantom: std::marker::PhantomData<&'ast ()>,
}

impl<'ast> TypeCompiler<'ast> {
    /// Create a new type compiler
    fn new(registry: Registry<'ast>) -> Self {
        Self {
            registry,
            type_map: FxHashMap::default(),
            namespace_path: Vec::new(),
            imported_namespaces: Vec::new(),
            errors: Vec::new(),
            _phantom: std::marker::PhantomData,
        }
    }

    /// Perform Pass 2a type compilation on a script
    pub fn compile(
        script: &Script<'ast>,
        registry: Registry<'ast>,
    ) -> TypeCompilationData<'ast> {
        let mut compiler = Self::new(registry);
        compiler.visit_script(script);

        TypeCompilationData {
            registry: compiler.registry,
            type_map: compiler.type_map,
            errors: compiler.errors,
        }
    }

    /// Visit the entire script
    fn visit_script(&mut self, script: &Script<'ast>) {
        for item in script.items() {
            self.visit_item(item);
        }
    }

    /// Visit a top-level item
    fn visit_item(&mut self, item: &Item<'ast>) {
        match item {
            Item::Function(func) => self.visit_function(func, None),
            Item::Class(class) => self.visit_class(class),
            Item::Interface(iface) => self.visit_interface(iface),
            Item::Enum(enum_decl) => self.visit_enum(enum_decl),
            Item::GlobalVar(var) => self.visit_global_var(var),
            Item::Namespace(ns) => self.visit_namespace(ns),
            Item::Typedef(typedef) => self.visit_typedef(typedef),
            Item::Funcdef(funcdef) => self.visit_funcdef(funcdef),
            Item::Mixin(_) | Item::Import(_) => {
                // Skip mixins and imports for now
            }
            Item::UsingNamespace(using) => self.visit_using_namespace(using),
        }
    }

    /// Visit a function declaration and fill in its signature
    fn visit_function(&mut self, func: &FunctionDecl<'ast>, object_type: Option<TypeId>) {
        let qualified_name = self.build_qualified_name(func.name.name);

        // Resolve parameter types
        // Note: void parameters can't occur from parsing (syntax doesn't allow `void param_name`)
        let mut params = Vec::with_capacity(func.params.len());
        for p in func.params.iter() {
            if let Some(dt) = self.resolve_param_type(&p.ty) {
                params.push(dt);
            }
        }

        // Check if we got all params (if any failed to resolve, we already logged errors)
        if params.len() != func.params.len() {
            // Some params failed to resolve, skip this function
            return;
        }

        // Resolve return type (default to void if None, e.g., for constructors)
        let return_type = if let Some(ret_ty) = func.return_type {
            match self.resolve_type_expr(&ret_ty.ty) {
                Some(dt) => dt,
                None => return, // Error already logged
            }
        } else {
            // Constructor or destructor - use void type
            DataType::simple(self.registry.void_type)
        };

        // Build function traits from AST
        let is_constructor = func.is_constructor();
        let is_destructor = func.is_destructor;
        let is_const = func.is_const;
        let is_explicit = func.attrs.explicit;
        // Method-level 'final' is in attrs, not modifiers (modifiers.final_ is for class-level)
        let is_final = func.attrs.final_;
        let is_virtual = object_type.is_some() && !is_final && !is_constructor && !is_destructor;
        // A function is abstract if it has no body (pure virtual)
        let is_abstract = func.body.is_none() && is_virtual;

        let traits = FunctionTraits {
            is_constructor,
            is_destructor,
            is_final,
            is_virtual,
            is_abstract,
            is_const,
            is_explicit,
            auto_generated: None,  // User-defined functions from AST are not auto-generated
        };

        // Capture default arguments from AST
        let mut default_args = Vec::with_capacity(func.params.len());
        for p in func.params.iter() {
            default_args.push(p.default);
        }

        // Update the function signature in the registry
        self.registry.update_function_signature(&qualified_name, params, return_type, object_type, traits, default_args);

        // Scan function body for type expressions that need instantiation
        // This ensures template types like array<int> used in local variables
        // are instantiated before Pass 2b
        if let Some(body) = &func.body {
            self.scan_block(body);
        }
    }

    /// Visit a class declaration and fill in its details
    fn visit_class(&mut self, class: &ClassDecl<'ast>) {
        let qualified_name = self.build_qualified_name(class.name.name);

        // Look up the class type (registered in Pass 1)
        let type_id = match self.registry.lookup_type(&qualified_name) {
            Some(id) => id,
            None => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    class.span,
                    format!("class '{}' was not registered in Pass 1", qualified_name),
                ));
                return;
            }
        };

        // Resolve base class, interfaces, and mixins from inheritance list
        // In AngelScript, the first item in inheritance is the base class (if it's a class),
        // remaining items are interfaces or mixins
        let mut base_class = None;
        let mut interfaces = Vec::new();
        let mut mixins = Vec::new();

        for (i, inherited_ident) in class.inheritance.iter().enumerate() {
            // Look up the type or mixin
            let inherited_name = self.build_inherited_name(inherited_ident);

            // First check if it's a mixin
            if self.registry.is_mixin(&inherited_name) {
                mixins.push(inherited_name);
                continue;
            }

            if let Some(inherited_id) = self.registry.lookup_type(&inherited_name) {
                let inherited_typedef = self.registry.get_type(inherited_id);

                // First item can be a base class (if it's a class type)
                if i == 0 && inherited_typedef.is_class() {
                    // Check that base class is not final
                    if self.registry.is_class_final(inherited_id) {
                        self.errors.push(SemanticError::new(
                            SemanticErrorKind::CannotInheritFromFinal,
                            inherited_ident.span,
                            format!("cannot inherit from final class '{}'", inherited_name),
                        ));
                    }

                    // Check for circular inheritance
                    if self.registry.would_create_circular_inheritance(type_id, inherited_id) {
                        self.errors.push(SemanticError::new(
                            SemanticErrorKind::CircularInheritance,
                            inherited_ident.span,
                            format!("circular inheritance detected: '{}' cannot inherit from '{}'", qualified_name, inherited_name),
                        ));
                        // Don't set base_class to prevent further issues
                        continue;
                    }

                    base_class = Some(inherited_id);
                } else if inherited_typedef.is_interface() {
                    interfaces.push(inherited_id);
                } else if i == 0 {
                    // First item is not a class or interface
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::UndefinedType,
                        inherited_ident.span,
                        format!("'{}' is not a class or interface", inherited_name),
                    ));
                }
            } else {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    inherited_ident.span,
                    format!("undefined type '{}'", inherited_name),
                ));
            }
        }

        // Process mixins: add their interfaces, methods, and fields
        // Mixins must be processed before we collect class methods/fields
        for mixin_name in &mixins {
            if let Some(mixin) = self.registry.lookup_mixin(mixin_name) {
                // Add interfaces required by the mixin
                for iface_name in &mixin.required_interfaces {
                    if let Some(iface_id) = self.registry.lookup_type(iface_name)
                        && !interfaces.contains(&iface_id) {
                            interfaces.push(iface_id);
                        }
                }
            }
        }

        // Collect the names of methods and fields defined in this class
        // These take precedence over mixin members
        let mut class_method_names: FxHashSet<&str> = FxHashSet::default();
        let mut class_field_names: FxHashSet<&str> = FxHashSet::default();
        for member in class.members.iter() {
            match member {
                ClassMember::Method(method) => { class_method_names.insert(method.name.name); }
                ClassMember::Field(field) => { class_field_names.insert(field.name.name); }
                _ => {}
            }
        }

        // Resolve field types from class definition
        let mut fields = Vec::new();
        for member in class.members {
            if let ClassMember::Field(field) = member
                && let Some(field_type) = self.resolve_type_expr(&field.ty) {
                    // Void type cannot be used for class fields
                    if field_type.type_id == crate::semantic::VOID_TYPE {
                        self.errors.push(SemanticError::new(
                            SemanticErrorKind::VoidExpression,
                            field.ty.span,
                            format!("cannot declare field '{}' of type 'void'", field.name.name),
                        ));
                        continue;
                    }
                    // Convert AST visibility to semantic visibility
                    let visibility = match field.visibility {
                        crate::ast::Visibility::Public => Visibility::Public,
                        crate::ast::Visibility::Private => Visibility::Private,
                        crate::ast::Visibility::Protected => Visibility::Protected,
                    };
                    fields.push(FieldDef {
                        name: field.name.name.to_string(),
                        data_type: field_type,
                        visibility,
                    });
                }
        }

        // Add fields from mixins that don't conflict with class fields or inherited fields
        // Mixin fields are NOT added if already inherited from base class
        let inherited_field_names: FxHashSet<String> = if let Some(base_id) = base_class {
            let base_fields = self.registry.get_class_fields(base_id);
            let mut set = FxHashSet::default();
            for f in base_fields.iter() {
                set.insert(f.name.clone());
            }
            set
        } else {
            FxHashSet::default()
        };

        for mixin_name in &mixins {
            if let Some(mixin) = self.registry.lookup_mixin(mixin_name) {
                for member in mixin.members {
                    if let ClassMember::Field(field) = member {
                        let field_name = field.name.name;
                        // Skip if already defined in class or inherited from base
                        if class_field_names.contains(field_name) || inherited_field_names.contains(field_name) {
                            continue;
                        }
                        if let Some(field_type) = self.resolve_type_expr(&field.ty) {
                            let visibility = match field.visibility {
                                crate::ast::Visibility::Public => Visibility::Public,
                                crate::ast::Visibility::Private => Visibility::Private,
                                crate::ast::Visibility::Protected => Visibility::Protected,
                            };
                            fields.push(FieldDef {
                                name: field_name.to_string(),
                                data_type: field_type,
                                visibility,
                            });
                        }
                    }
                }
            }
        }

        // Collect method IDs and operator methods
        let mut method_ids = Vec::new();
        let mut operator_methods: FxHashMap<OperatorBehavior, FunctionId> = FxHashMap::default();
        let mut explicit_properties: FxHashMap<String, crate::semantic::types::PropertyAccessors> = FxHashMap::default();

        // First, process methods from mixins (they take precedence over inherited methods,
        // but NOT over methods explicitly defined in this class)
        for mixin_name in &mixins {
            if let Some(mixin) = self.registry.lookup_mixin(mixin_name) {
                for member in mixin.members {
                    if let ClassMember::Method(method) = member {
                        // Skip if class already defines a method with this name
                        if class_method_names.contains(method.name.name) {
                            continue;
                        }
                        // Skip deleted methods
                        if method.attrs.delete {
                            continue;
                        }

                        // Register the mixin method as a method of this class
                        // This needs to be done here because mixin methods weren't registered in Pass 1
                        self.register_mixin_method(method, type_id, &mut method_ids, &mut operator_methods, &mut explicit_properties);
                    }
                }
            }
        }

        // Then process methods defined directly in the class
        for member in class.members {
            if let ClassMember::Method(method) = member {
                // Skip deleted methods - they were not registered in Pass 1
                if method.attrs.delete {
                    continue;
                }

                // Register method signature
                self.visit_function(method, Some(type_id));

                // Find the function ID for this method
                // Methods are registered with their unqualified name in the current namespace
                // We filter by object_type to only get methods belonging to THIS class
                let method_qualified_name = self.build_qualified_name(method.name.name);
                let all_funcs = self.registry.lookup_functions(&method_qualified_name);
                let mut func_ids = Vec::with_capacity(all_funcs.len().min(4));
                for &id in all_funcs {
                    if self.registry.get_function(id).object_type == Some(type_id) {
                        func_ids.push(id);
                    }
                }
                method_ids.extend(func_ids.iter().copied());

                // Check if this is an operator method
                // We need to resolve the return type to identify the target type
                if let Some(ret_ty_expr) = method.return_type
                    && let Some(return_type) = self.resolve_type_expr(&ret_ty_expr.ty)
                        && let Some(op_behavior) = self.parse_operator_method(method.name.name, &return_type) {
                            // Each operator behavior should have exactly one function
                            if let Some(&func_id) = func_ids.first() {
                                operator_methods.insert(op_behavior, func_id);
                            }
                        }

                // Check if this is an explicit property accessor method
                // Pattern: get_propname() or set_propname(T) with 'property' attribute
                if method.attrs.property
                    && let Some(prop_info) = self.parse_property_method(method.name.name) {
                        let (prop_name, is_getter) = prop_info;

                        if let Some(&func_id) = func_ids.first() {
                            // Convert method visibility to semantic visibility for the property
                            let method_visibility = match method.visibility {
                                crate::ast::Visibility::Public => Visibility::Public,
                                crate::ast::Visibility::Private => Visibility::Private,
                                crate::ast::Visibility::Protected => Visibility::Protected,
                            };

                            let accessor = explicit_properties.entry(prop_name)
                                .or_insert_with(|| crate::semantic::types::PropertyAccessors {
                                    getter: None,
                                    setter: None,
                                    visibility: method_visibility,
                                });

                            if is_getter {
                                accessor.getter = Some(func_id);
                            } else {
                                accessor.setter = Some(func_id);
                            }
                        }
                    }
            }
        }

        // Fill in params for auto-generated methods (generated in Pass 1 with empty params)
        // Auto-generated methods are not in the AST, so visit_function() won't process them.
        // After the loop above, all AST methods have been processed by visit_function().
        // We use the auto_generated field to identify and differentiate between methods:
        // - Default constructor: auto_generated = Some(DefaultConstructor) → keep params empty
        // - Copy constructor: auto_generated = Some(CopyConstructor) → fill with const ClassName&inout
        // - OpAssign: auto_generated = Some(OpAssign) → fill with const ClassName&inout, return ClassName&
        let constructors = self.registry.find_constructors(type_id);

        for &ctor_id in &constructors {
            let func = self.registry.get_function(ctor_id);

            // Check if this is an auto-generated copy constructor
            if let Some(AutoGeneratedMethod::CopyConstructor) = func.traits.auto_generated {
                let param_type = DataType {
                    type_id,
                    is_const: true,
                    is_handle: false,
                    is_handle_to_const: false,
                    ref_modifier: RefModifier::InOut,
                };

                self.registry.update_function_params(ctor_id, vec![param_type]);
            }
            // Default constructors (auto_generated = Some(DefaultConstructor)) keep empty params
            // User-defined constructors (auto_generated = None) already have params from AST
        }

        // Fill in params and return type for auto-generated opAssign
        if let Some(op_assign_id) = self.registry.find_operator_method(type_id, OperatorBehavior::OpAssign) {
            let func = self.registry.get_function(op_assign_id);

            if let Some(AutoGeneratedMethod::OpAssign) = func.traits.auto_generated {
                // Parameter: const ClassName&inout
                let param_type = DataType {
                    type_id,
                    is_const: true,
                    is_handle: false,
                    is_handle_to_const: false,
                    ref_modifier: RefModifier::InOut,
                };

                // Return type: ClassName& (reference to self for chaining)
                let return_type = DataType {
                    type_id,
                    is_const: false,
                    is_handle: false,
                    is_handle_to_const: false,
                    ref_modifier: RefModifier::InOut,
                };

                self.registry.update_function_params(op_assign_id, vec![param_type]);
                self.registry.update_function_return_type(op_assign_id, return_type);
            }
        }

        // Process virtual properties - fill in params/return types and map to properties
        let mut properties: FxHashMap<String, crate::semantic::types::PropertyAccessors> = FxHashMap::default();

        for member in class.members {
            if let ClassMember::VirtualProperty(prop) = member {
                let prop_name = prop.name.name.to_string();

                // Convert AST visibility to semantic visibility
                let prop_visibility = match prop.visibility {
                    crate::ast::Visibility::Public => Visibility::Public,
                    crate::ast::Visibility::Private => Visibility::Private,
                    crate::ast::Visibility::Protected => Visibility::Protected,
                };

                let mut prop_accessors = crate::semantic::types::PropertyAccessors {
                    getter: None,
                    setter: None,
                    visibility: prop_visibility,
                };

                // Resolve property type
                let prop_type = if prop.ty.ty.is_void() {
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::InvalidOperation,
                        prop.span,
                        "property cannot have void type".to_string(),
                    ));
                    continue;
                } else {
                    match self.resolve_type_expr(&prop.ty.ty) {
                        Some(dt) => dt,
                        None => {
                            self.errors.push(SemanticError::new(
                                SemanticErrorKind::UndefinedType,
                                prop.span,
                                format!("undefined type for property '{}'", prop_name),
                            ));
                            continue;
                        }
                    }
                };

                // Process each accessor (get/set)
                for accessor in prop.accessors {
                    match accessor.kind {
                        crate::ast::PropertyAccessorKind::Get => {
                            // Find the synthetic getter function
                            let getter_name = format!("get_{}", prop_name);
                            let getter_qualified = self.build_qualified_name(&getter_name);

                            if let Some(getter_ids) = self.registry.lookup_functions(&getter_qualified).first() {
                                let getter_id = *getter_ids;

                                // Update getter return type to match property type
                                self.registry.update_function_return_type(getter_id, prop_type.clone());

                                prop_accessors.getter = Some(getter_id);
                            }
                        }
                        crate::ast::PropertyAccessorKind::Set => {
                            // Find the synthetic setter function
                            let setter_name = format!("set_{}", prop_name);
                            let setter_qualified = self.build_qualified_name(&setter_name);

                            if let Some(setter_ids) = self.registry.lookup_functions(&setter_qualified).first() {
                                let setter_id = *setter_ids;

                                // Update setter parameter to receive property value
                                // Parameter: T value (or const T& for handles/objects)
                                self.registry.update_function_params(setter_id, vec![prop_type.clone()]);

                                prop_accessors.setter = Some(setter_id);
                            }
                        }
                    }
                }

                // Add to properties map
                properties.insert(prop_name, prop_accessors);
            }
        }

        // Merge explicit properties with virtual properties
        // If both exist for the same property name, virtual property takes precedence (was declared first)
        for (prop_name, explicit_accessor) in explicit_properties {
            properties.entry(prop_name).or_insert(explicit_accessor);
        }

        // Update the class definition in the registry
        self.registry.update_class_details(type_id, fields, method_ids, base_class, interfaces, operator_methods, properties);

        // Validate interface implementation (for non-abstract classes)
        self.validate_interface_implementation(class, type_id);

        // Validate method overrides ('override' keyword and 'final' checking)
        self.validate_method_overrides(class, type_id);
    }

    /// Visit an interface declaration and fill in its details
    fn visit_interface(&mut self, iface: &InterfaceDecl<'ast>) {
        let qualified_name = self.build_qualified_name(iface.name.name);

        // Look up the interface type (registered in Pass 1)
        let type_id = match self.registry.lookup_type(&qualified_name) {
            Some(id) => id,
            None => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    iface.span,
                    format!("interface '{}' was not registered in Pass 1", qualified_name),
                ));
                return;
            }
        };

        // Resolve method signatures
        let mut methods = Vec::new();
        for member in iface.members {
            if let crate::ast::decl::InterfaceMember::Method(method) = member
                && let Some(method_sig) = self.resolve_interface_method(method) {
                    methods.push(method_sig);
                }
        }

        // Update the interface definition in the registry
        self.registry.update_interface_details(type_id, methods);
    }

    /// Resolve an interface method to a MethodSignature
    fn resolve_interface_method(&mut self, method: &InterfaceMethod<'ast>) -> Option<MethodSignature> {
        // Resolve parameter types
        let params: Vec<DataType> = method
            .params
            .iter()
            .filter_map(|p| self.resolve_param_type(&p.ty))
            .collect();

        if params.len() != method.params.len() {
            return None; // Some params failed to resolve
        }

        // Resolve return type
        let return_type = self.resolve_type_expr(&method.return_type.ty)?;

        Some(MethodSignature {
            name: method.name.name.to_string(),
            params,
            return_type,
        })
    }

    /// Visit an enum declaration (already complete from Pass 1)
    fn visit_enum(&mut self, _enum_decl: &EnumDecl<'ast>) {
        // Enums are fully registered in Pass 1, nothing to do here
    }

    /// Visit a global variable declaration and resolve its type
    fn visit_global_var(&mut self, var: &GlobalVarDecl<'ast>) {
        // Check if this is an auto type declaration
        let is_auto = matches!(var.ty.base, TypeBase::Auto);

        let var_type = if is_auto {
            // Auto type requires an initializer
            let init = match var.init {
                Some(init) => init,
                None => {
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::TypeMismatch,
                        var.span,
                        "cannot use 'auto' without an initializer".to_string(),
                    ));
                    return;
                }
            };

            // Infer type from the initializer expression
            match self.infer_type_from_expr(init) {
                Some(mut inferred_type) => {
                    // Apply const from "const auto"
                    if var.ty.is_const {
                        inferred_type.is_const = true;
                    }

                    // Apply handle from "auto@"
                    for suffix in var.ty.suffixes {
                        match suffix {
                            TypeSuffix::Handle { is_const } => {
                                if !inferred_type.is_handle {
                                    inferred_type.is_handle = true;
                                }
                                if *is_const {
                                    inferred_type.is_const = true;
                                }
                            }
                            TypeSuffix::Array => {
                                self.errors.push(SemanticError::new(
                                    SemanticErrorKind::TypeMismatch,
                                    var.ty.span,
                                    "cannot use array suffix with 'auto'; type is inferred from initializer".to_string(),
                                ));
                                return;
                            }
                        }
                    }

                    inferred_type
                }
                None => {
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::TypeMismatch,
                        var.span,
                        "cannot infer type from initializer expression".to_string(),
                    ));
                    return;
                }
            }
        } else {
            // Resolve the variable's type normally
            match self.resolve_type_expr(&var.ty) {
                Some(ty) => ty,
                None => return,
            }
        };

        // Register the global variable with its resolved type
        self.registry.register_global_var(
            var.name.name.to_string(),
            self.namespace_path.clone(),
            var_type,
        );
    }

    /// Infer the type of a simple expression (for auto type inference).
    /// This handles literals and simple constant expressions.
    fn infer_type_from_expr(&self, expr: &Expr<'ast>) -> Option<DataType> {
        use crate::ast::expr::LiteralKind;
        use crate::ast::BinaryOp;

        match expr {
            Expr::Literal(lit) => {
                let type_id = match &lit.kind {
                    LiteralKind::Int(_) => INT32_TYPE,
                    LiteralKind::Float(_) => FLOAT_TYPE,
                    LiteralKind::Double(_) => DOUBLE_TYPE,
                    LiteralKind::String(_) => STRING_TYPE,
                    LiteralKind::Bool(_) => BOOL_TYPE,
                    LiteralKind::Null => {
                        // null requires explicit type
                        return None;
                    }
                };
                Some(DataType::simple(type_id))
            }
            Expr::Paren(paren) => {
                // Unwrap parentheses
                self.infer_type_from_expr(paren.expr)
            }
            Expr::Unary(unary) => {
                // For unary operators, infer from operand
                let operand_type = self.infer_type_from_expr(unary.operand)?;
                // Most unary operators preserve type (-, +, !, ~)
                Some(operand_type)
            }
            Expr::Binary(binary) => {
                // For binary operators, infer from operands
                let left_type = self.infer_type_from_expr(binary.left)?;
                let _right_type = self.infer_type_from_expr(binary.right)?;

                // Comparison and logical operators return bool
                match binary.op {
                    BinaryOp::Equal | BinaryOp::NotEqual | BinaryOp::Less | BinaryOp::LessEqual |
                    BinaryOp::Greater | BinaryOp::GreaterEqual | BinaryOp::LogicalAnd | BinaryOp::LogicalOr |
                    BinaryOp::Is | BinaryOp::NotIs => {
                        Some(DataType::simple(BOOL_TYPE))
                    }
                    _ => {
                        // Arithmetic/bitwise operators - use left type or promote
                        // For simplicity, use left type
                        Some(left_type)
                    }
                }
            }
            Expr::Ternary(ternary) => {
                // Infer from true branch
                self.infer_type_from_expr(ternary.then_expr)
            }
            // For more complex expressions, we can't infer the type at this stage
            _ => None,
        }
    }

    /// Visit a namespace declaration
    fn visit_namespace(&mut self, ns: &NamespaceDecl<'ast>) {
        // Enter namespace (handle path which can be nested like A::B::C)
        for ident in ns.path {
            self.namespace_path.push(ident.name.to_string());
        }

        // Save imported namespaces count for scoping
        let import_count_before = self.imported_namespaces.len();

        // Visit items inside namespace
        for item in ns.items {
            self.visit_item(item);
        }

        // Remove any imports added within this namespace scope
        self.imported_namespaces.truncate(import_count_before);

        // Exit namespace (pop all path components we added)
        for _ in ns.path {
            self.namespace_path.pop();
        }
    }

    /// Visit a using namespace declaration
    fn visit_using_namespace(&mut self, using: &UsingNamespaceDecl<'ast>) {
        // Build the fully qualified namespace path
        let ns_path: String = using.path
            .iter()
            .map(|id| id.name)
            .collect::<Vec<_>>()
            .join("::");

        // Record the import for use in type resolution
        self.imported_namespaces.push(ns_path);
    }

    /// Visit a typedef declaration
    ///
    /// Typedefs create type aliases for primitive types.
    /// Example: `typedef float real;` creates `real` as an alias for `float`.
    fn visit_typedef(&mut self, typedef: &TypedefDecl<'ast>) {
        // Resolve the base type
        let base_type = match self.resolve_type_expr(&typedef.base_type) {
            Some(dt) => dt,
            None => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    typedef.span,
                    format!("cannot resolve base type for typedef '{}'", typedef.name.name),
                ));
                return;
            }
        };

        // Build the qualified name for the alias
        let alias_name = self.build_qualified_name(typedef.name.name);

        // Register the alias
        self.registry.register_type_alias(&alias_name, base_type.type_id);
    }

    /// Visit a funcdef declaration and fill in its signature
    fn visit_funcdef(&mut self, funcdef: &FuncdefDecl<'ast>) {
        let qualified_name = self.build_qualified_name(funcdef.name.name);

        // Look up the funcdef type (registered in Pass 1)
        let type_id = match self.registry.lookup_type(&qualified_name) {
            Some(id) => id,
            None => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    funcdef.span,
                    format!("funcdef '{}' was not registered in Pass 1", qualified_name),
                ));
                return;
            }
        };

        // Resolve parameter types
        let params: Vec<DataType> = funcdef
            .params
            .iter()
            .filter_map(|p| self.resolve_param_type(&p.ty))
            .collect();

        if params.len() != funcdef.params.len() {
            return; // Some params failed to resolve
        }

        // Resolve return type
        let return_type = match self.resolve_type_expr(&funcdef.return_type.ty) {
            Some(dt) => dt,
            None => return, // Error already logged
        };

        // Update the funcdef in the registry
        self.registry.update_funcdef_signature(type_id, params, return_type);
    }

    /// Resolve a TypeExpr AST node to a complete DataType
    ///
    /// This is the core type resolution method that:
    /// - Looks up the base type in the registry
    /// - Handles scoped names (Namespace::Type)
    /// - Instantiates templates recursively
    /// - Applies type modifiers (const, @)
    /// - Stores the result in type_map for later reference
    fn resolve_type_expr(&mut self, expr: &TypeExpr<'ast>) -> Option<DataType> {
        // Step 1: Resolve the base type name
        let base_type_id = self.resolve_base_type(&expr.base, expr.scope.as_ref(), expr.span)?;

        // Step 2: Handle template arguments
        let type_id = if !expr.template_args.is_empty() {
            // Resolve all template argument types recursively (pre-allocate capacity)
            let mut arg_types = Vec::with_capacity(expr.template_args.len());
            for arg in expr.template_args {
                match self.resolve_type_expr(arg) {
                    Some(dt) => arg_types.push(dt),
                    None => return None, // Error already recorded
                }
            }

            // Instantiate the template
            match self.registry.instantiate_template(base_type_id, arg_types) {
                Ok(instance_id) => instance_id,
                Err(err) => {
                    self.errors.push(err);
                    return None;
                }
            }
        } else {
            base_type_id
        };

        // Step 3: Build DataType with modifiers from suffixes
        let mut data_type = DataType::simple(type_id);

        // Check if this is a template instance that's a reference type (array, dictionary)
        // These should always be handles
        if let TypeDef::TemplateInstance { template, .. } = self.registry.get_type(type_id) {
            let template_id = *template;
            if template_id == crate::semantic::ARRAY_TEMPLATE || template_id == crate::semantic::DICT_TEMPLATE {
                data_type.is_handle = true;
            }
        }

        // Apply const modifier from leading const keyword
        if expr.is_const {
            data_type.is_const = true;
        }

        // Apply modifiers from suffixes
        // Note: In AngelScript, only the first @ suffix matters for handle semantics
        for suffix in expr.suffixes {
            match suffix {
                TypeSuffix::Handle { is_const } => {
                    data_type.is_handle = true;
                    data_type.is_handle_to_const = *is_const;
                    // In AngelScript, leading const + @ means handle to const
                    if expr.is_const && data_type.is_handle {
                        data_type.is_handle_to_const = true;
                        data_type.is_const = false; // Move const to handle_to_const
                    }
                    break; // Only first @ matters
                }
                TypeSuffix::Array => {
                    // Array suffix T[] creates array<T>
                    // Instantiate the array template with the current type as element type
                    match self.registry.instantiate_template(
                        crate::semantic::ARRAY_TEMPLATE,
                        vec![data_type.clone()],
                    ) {
                        Ok(array_type_id) => {
                            // Arrays are reference types, so they're handles
                            data_type = DataType::with_handle(array_type_id, false);
                        }
                        Err(err) => {
                            self.errors.push(err);
                            return None;
                        }
                    }
                }
            }
        }

        // Step 4: Store in type_map for later reference
        self.type_map.insert(expr.span, data_type.clone());

        Some(data_type)
    }

    /// Resolve a parameter type (type + reference modifier).
    ///
    /// This handles the full ParamType which includes both the type expression
    /// and the reference kind (&in, &out, &inout).
    fn resolve_param_type(&mut self, param: &ParamType<'ast>) -> Option<DataType> {
        let mut data_type = self.resolve_type_expr(&param.ty)?;

        // Convert AST RefKind to semantic RefModifier
        data_type.ref_modifier = match param.ref_kind {
            RefKind::None => RefModifier::None,
            RefKind::Ref => RefModifier::InOut,      // Bare `&` is `&inout`
            RefKind::RefIn => RefModifier::In,
            RefKind::RefOut => RefModifier::Out,
            RefKind::RefInOut => RefModifier::InOut,
        };

        Some(data_type)
    }

    /// Resolve the base type (without template args or modifiers)
    fn resolve_base_type(
        &mut self,
        base: &TypeBase<'ast>,
        scope: Option<&crate::ast::Scope<'ast>>,
        span: Span,
    ) -> Option<TypeId> {
        match base {
            TypeBase::Primitive(prim) => Some(self.primitive_to_type_id(*prim)),

            TypeBase::Named(ident) => {
                // Build the qualified name
                let type_name = if let Some(scope) = scope {
                    // Scoped type: Namespace::Type
                    self.build_scoped_name(scope, ident.name)
                } else {
                    // Try current namespace first, then ancestor namespaces, then global, then imports
                    // For namespace_path = ["Utils", "Colors"], try:
                    //   1. Utils::Colors::Color
                    //   2. Utils::Color
                    //   3. Color (global)
                    //   4. ImportedNs::Color (for each `using namespace ImportedNs`)
                    let qualified = self.build_qualified_name(ident.name);

                    // Look up in registry - full namespace qualified
                    if let Some(type_id) = self.registry.lookup_type(&qualified) {
                        return Some(type_id);
                    }

                    // Try progressively shorter namespace prefixes
                    if !self.namespace_path.is_empty() {
                        for prefix_len in (1..self.namespace_path.len()).rev() {
                            // Build ancestor qualified name without intermediate allocations
                            let ancestor_qualified = Self::build_qualified_name_from_slice(
                                &self.namespace_path[..prefix_len],
                                ident.name,
                            );
                            if let Some(type_id) = self.registry.lookup_type(&ancestor_qualified) {
                                return Some(type_id);
                            }
                        }
                    }

                    // Try global scope
                    if let Some(type_id) = self.registry.lookup_type(ident.name) {
                        return Some(type_id);
                    }

                    // Try imported namespaces
                    let mut found_in_import: Option<TypeId> = None;
                    for ns in &self.imported_namespaces {
                        let imported_qualified = format!("{}::{}", ns, ident.name);
                        if let Some(type_id) = self.registry.lookup_type(&imported_qualified) {
                            if found_in_import.is_some() {
                                // Ambiguous - found in multiple imported namespaces
                                self.errors.push(SemanticError::new(
                                    SemanticErrorKind::AmbiguousName,
                                    span,
                                    format!("ambiguous type '{}' found in multiple imported namespaces", ident.name),
                                ));
                                return None;
                            }
                            found_in_import = Some(type_id);
                        }
                    }
                    if let Some(type_id) = found_in_import {
                        return Some(type_id);
                    }

                    // Not found anywhere
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::UndefinedType,
                        span,
                        format!("undefined type '{}'", ident.name),
                    ));
                    return None;
                };

                // Look up the type
                match self.registry.lookup_type(&type_name) {
                    Some(type_id) => Some(type_id),
                    None => {
                        self.errors.push(SemanticError::new(
                            SemanticErrorKind::UndefinedType,
                            span,
                            format!("undefined type '{}'", type_name),
                        ));
                        None
                    }
                }
            }

            TypeBase::Auto => {
                // Auto type inference - not supported in type resolution yet
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    span,
                    "auto type inference not yet supported".to_string(),
                ));
                None
            }

            TypeBase::Unknown => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    span,
                    "unknown type '?'".to_string(),
                ));
                None
            }

            TypeBase::TemplateParam(_) => {
                // Template parameters (e.g., "class T" in "array<class T>") are placeholders
                // used in FFI template type declarations. They are not resolved to a TypeId;
                // instead, they are captured separately as template parameter names.
                // Returning None here allows concrete types in mixed declarations like
                // "stringmap<string, class T>" to be resolved normally.
                None
            }
        }
    }

    /// Map a primitive type to its TypeId
    #[inline]
    fn primitive_to_type_id(&self, prim: PrimitiveType) -> TypeId {
        match prim {
            PrimitiveType::Void => self.registry.void_type,
            PrimitiveType::Bool => self.registry.bool_type,
            PrimitiveType::Int => self.registry.int32_type,
            PrimitiveType::Int8 => self.registry.int8_type,
            PrimitiveType::Int16 => self.registry.int16_type,
            PrimitiveType::Int64 => self.registry.int64_type,
            PrimitiveType::UInt => self.registry.uint32_type,
            PrimitiveType::UInt8 => self.registry.uint8_type,
            PrimitiveType::UInt16 => self.registry.uint16_type,
            PrimitiveType::UInt64 => self.registry.uint64_type,
            PrimitiveType::Float => self.registry.float_type,
            PrimitiveType::Double => self.registry.double_type,
        }
    }

    /// Build a scoped name from a Scope and identifier (no intermediate Vec allocation)
    fn build_scoped_name(&self, scope: &crate::ast::Scope<'ast>, name: &str) -> String {
        // Calculate capacity: sum of segment lengths + "::" separators + final name
        let capacity = scope.segments.iter().map(|s| s.name.len() + 2).sum::<usize>() + name.len();
        let mut result = String::with_capacity(capacity);
        for (i, segment) in scope.segments.iter().enumerate() {
            if i > 0 {
                result.push_str("::");
            }
            result.push_str(segment.name);
        }
        result.push_str("::");
        result.push_str(name);
        result
    }

    /// Build a qualified name from the current namespace path (no intermediate Vec allocation)
    fn build_qualified_name(&self, name: &str) -> String {
        Self::build_qualified_name_from_slice(&self.namespace_path, name)
    }

    /// Build a qualified name from a namespace path slice (static helper, no self needed)
    fn build_qualified_name_from_slice(namespace_path: &[String], name: &str) -> String {
        if namespace_path.is_empty() {
            name.to_string()
        } else {
            // Calculate capacity
            let capacity = namespace_path.iter().map(|s| s.len() + 2).sum::<usize>() + name.len();
            let mut result = String::with_capacity(capacity);
            for (i, part) in namespace_path.iter().enumerate() {
                if i > 0 {
                    result.push_str("::");
                }
                result.push_str(part);
            }
            result.push_str("::");
            result.push_str(name);
            result
        }
    }

    /// Build the full name from an IdentExpr used in inheritance (no intermediate Vec allocation)
    /// Handles both simple names (Base) and scoped names (Namespace::Interface).
    fn build_inherited_name(&self, ident_expr: &crate::ast::expr::IdentExpr) -> String {
        if let Some(scope) = &ident_expr.scope {
            // Has explicit scope - build directly without intermediate Vec
            let capacity = scope.segments.iter().map(|s| s.name.len() + 2).sum::<usize>() + ident_expr.ident.name.len();
            let mut result = String::with_capacity(capacity);
            for (i, segment) in scope.segments.iter().enumerate() {
                if i > 0 {
                    result.push_str("::");
                }
                result.push_str(segment.name);
            }
            result.push_str("::");
            result.push_str(ident_expr.ident.name);
            result
        } else {
            // No scope - apply current namespace
            self.build_qualified_name(ident_expr.ident.name)
        }
    }

    /// Parse an operator method name and return the OperatorBehavior if it's an operator
    ///
    /// Recognizes all operator methods: opAdd, opSub, opMul, opDiv, opIndex, opCall,
    /// opConv, opImplConv, opCast, opImplCast, and more.
    /// The return type is used as the target type for conversion operators.
    fn parse_operator_method(
        &self,
        method_name: &str,
        return_type: &DataType,
    ) -> Option<OperatorBehavior> {
        // Use the canonical from_method_name implementation
        // For conversion operators, the return type determines the target type
        OperatorBehavior::from_method_name(method_name, Some(return_type.type_id))
    }

    /// Parse an explicit property accessor method name
    /// Returns Some((property_name, is_getter)) if the name matches the pattern
    /// Pattern: get_propname() or set_propname(T)
    fn parse_property_method(&self, method_name: &str) -> Option<(String, bool)> {
        if let Some(prop_name) = method_name.strip_prefix("get_") {
            Some((prop_name.to_string(), true))
        } else { method_name.strip_prefix("set_").map(|prop_name| (prop_name.to_string(), false)) }
    }

    /// Register a method from a mixin as a method of the including class
    ///
    /// This registers a new function in the registry with the including class as the object type.
    /// The method is compiled in the context of the including class.
    fn register_mixin_method(
        &mut self,
        method: &FunctionDecl<'ast>,
        type_id: TypeId,
        method_ids: &mut Vec<FunctionId>,
        operator_methods: &mut FxHashMap<OperatorBehavior, FunctionId>,
        explicit_properties: &mut FxHashMap<String, crate::semantic::types::PropertyAccessors>,
    ) {
        // Resolve parameter types
        let params: Vec<DataType> = method
            .params
            .iter()
            .filter_map(|p| self.resolve_param_type(&p.ty))
            .collect();

        // Check if we got all params
        if params.len() != method.params.len() {
            return; // Some params failed to resolve
        }

        // Resolve return type
        let return_type = if let Some(ret_ty) = method.return_type {
            match self.resolve_type_expr(&ret_ty.ty) {
                Some(dt) => dt,
                None => return,
            }
        } else {
            DataType::simple(self.registry.void_type)
        };

        // Build function traits
        let is_constructor = method.is_constructor();
        let is_destructor = method.is_destructor;
        let is_const = method.is_const;
        let is_explicit = method.attrs.explicit;
        let is_final = method.attrs.final_;
        let is_virtual = !is_final && !is_constructor && !is_destructor;
        let is_abstract = method.body.is_none() && is_virtual;

        let traits = FunctionTraits {
            is_constructor,
            is_destructor,
            is_final,
            is_virtual,
            is_abstract,
            is_const,
            is_explicit,
            auto_generated: None,
        };

        // Capture default arguments
        let default_args: Vec<Option<&'ast Expr<'ast>>> = method
            .params
            .iter()
            .map(|p| p.default)
            .collect();

        // Get a new function ID
        let func_id = self.registry.next_function_id();

        // Convert AST visibility to semantic visibility
        let visibility = match method.visibility {
            crate::ast::Visibility::Public => Visibility::Public,
            crate::ast::Visibility::Private => Visibility::Private,
            crate::ast::Visibility::Protected => Visibility::Protected,
        };

        // Create and register the function
        let func_def = crate::semantic::types::registry::FunctionDef {
            id: func_id,
            name: method.name.name.to_string(),
            namespace: self.namespace_path.clone(),
            params,
            return_type: return_type.clone(),
            object_type: Some(type_id),
            traits,
            is_native: false,
            default_args,
            visibility,
            signature_filled: true, // Interface method - fully filled here
        };

        self.registry.register_function(func_def);
        self.registry.add_method_to_class(type_id, func_id);
        method_ids.push(func_id);

        // Check if this is an operator method
        if let Some(op_behavior) = self.parse_operator_method(method.name.name, &return_type) {
            operator_methods.insert(op_behavior, func_id);
        }

        // Check if this is an explicit property accessor method
        if method.attrs.property
            && let Some((prop_name, is_getter)) = self.parse_property_method(method.name.name) {
                let accessor = explicit_properties.entry(prop_name)
                    .or_insert_with(|| crate::semantic::types::PropertyAccessors {
                        getter: None,
                        setter: None,
                        visibility,  // Use the method's visibility for the property
                    });

                if is_getter {
                    accessor.getter = Some(func_id);
                } else {
                    accessor.setter = Some(func_id);
                }
            }
    }

    /// Validate that a non-abstract class implements all interface methods
    ///
    /// For each interface the class implements (directly or via inheritance),
    /// checks that the class provides a method with matching signature.
    fn validate_interface_implementation(
        &mut self,
        class: &ClassDecl<'ast>,
        type_id: TypeId,
    ) {
        // Skip validation for abstract classes - they can defer implementation
        if class.modifiers.abstract_ {
            return;
        }

        // Get all interfaces this class must implement
        let interfaces = self.registry.get_all_interfaces(type_id);

        for interface_id in interfaces {
            // Get interface method signatures
            let interface_methods = match self.registry.get_interface_methods(interface_id) {
                Some(methods) => methods.to_vec(), // Clone to avoid borrow issues
                None => continue,
            };

            let interface_name = self.registry.get_type(interface_id).qualified_name().to_string();

            // Check each interface method is implemented
            for method_sig in &interface_methods {
                if !self.registry.has_method_matching_interface(type_id, method_sig) {
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::MissingInterfaceMethod,
                        class.span,
                        format!(
                            "class '{}' does not implement interface method '{}' from '{}'",
                            class.name.name,
                            method_sig.name,
                            interface_name,
                        ),
                    ));
                }
            }
        }
    }

    /// Validate methods with 'override' keyword have a matching base method
    ///
    /// Also validates that methods are not overriding a final method.
    fn validate_method_overrides(
        &mut self,
        class: &ClassDecl<'ast>,
        type_id: TypeId,
    ) {
        for member in class.members {
            if let ClassMember::Method(method) = member {
                let method_name = method.name.name;

                // Check if method has 'override' attribute
                if method.attrs.override_ {
                    // Get method signature for matching
                    let params: Vec<DataType> = method
                        .params
                        .iter()
                        .filter_map(|p| self.resolve_param_type(&p.ty))
                        .collect();

                    let return_type = method
                        .return_type
                        .and_then(|rt| self.resolve_type_expr(&rt.ty))
                        .unwrap_or_else(|| DataType::simple(crate::semantic::types::VOID_TYPE));

                    // Check there's a base method to override
                    let base_method = self.registry.find_base_method_with_signature(
                        type_id,
                        method_name,
                        &params,
                        &return_type,
                    );

                    if base_method.is_none() {
                        self.errors.push(SemanticError::new(
                            SemanticErrorKind::OverrideWithoutBase,
                            method.span,
                            format!(
                                "method '{}' is marked 'override' but no matching base method exists",
                                method_name,
                            ),
                        ));
                    }
                }

                // Check if method is trying to override a final method
                // This applies whether or not 'override' keyword is used
                if let Some(final_method_id) = self.registry.is_base_method_final(type_id, method_name) {
                    let base_func = self.registry.get_function(final_method_id);
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::CannotOverrideFinal,
                        method.span,
                        format!(
                            "cannot override method '{}' which is marked 'final' in base class",
                            base_func.name,
                        ),
                    ));
                }
            }
        }
    }

    // ========================================================================
    // Function Body Scanning - Pre-instantiate template types
    // ========================================================================

    /// Scan a block for type expressions that need instantiation.
    ///
    /// This walks through all statements in a function body to find type
    /// expressions (e.g., `array<int>` in local variable declarations) and
    /// resolves them. This triggers template instantiation before Pass 2b.
    fn scan_block(&mut self, block: &Block<'ast>) {
        for stmt in block.stmts {
            self.scan_statement(stmt);
        }
    }

    /// Scan a single statement for type expressions.
    fn scan_statement(&mut self, stmt: &Stmt<'ast>) {
        match stmt {
            Stmt::VarDecl(var_decl) => {
                // Resolve the variable type (triggers template instantiation)
                // Skip auto types - they are resolved from initializers in function_processor
                if !matches!(var_decl.ty.base, TypeBase::Auto) {
                    self.resolve_type_expr(&var_decl.ty);
                }
                // Also scan initializers for expressions with types
                for var in var_decl.vars {
                    if let Some(init) = var.init {
                        self.scan_expression(init);
                    }
                }
            }
            Stmt::Expr(expr_stmt) => {
                if let Some(expr) = expr_stmt.expr {
                    self.scan_expression(expr);
                }
            }
            Stmt::Return(ret) => {
                if let Some(value) = ret.value {
                    self.scan_expression(value);
                }
            }
            Stmt::Block(block) => {
                self.scan_block(block);
            }
            Stmt::If(if_stmt) => {
                self.scan_expression(if_stmt.condition);
                self.scan_statement(if_stmt.then_stmt);
                if let Some(else_stmt) = if_stmt.else_stmt {
                    self.scan_statement(else_stmt);
                }
            }
            Stmt::While(while_stmt) => {
                self.scan_expression(while_stmt.condition);
                self.scan_statement(while_stmt.body);
            }
            Stmt::DoWhile(do_while) => {
                self.scan_statement(do_while.body);
                self.scan_expression(do_while.condition);
            }
            Stmt::For(for_stmt) => {
                // Scan initializer
                if let Some(init) = &for_stmt.init {
                    match init {
                        ForInit::VarDecl(var_decl) => {
                            // Skip auto types - resolved from initializers in function_processor
                            if !matches!(var_decl.ty.base, TypeBase::Auto) {
                                self.resolve_type_expr(&var_decl.ty);
                            }
                            for var in var_decl.vars {
                                if let Some(init_expr) = var.init {
                                    self.scan_expression(init_expr);
                                }
                            }
                        }
                        ForInit::Expr(expr) => {
                            self.scan_expression(expr);
                        }
                    }
                }
                // Scan condition
                if let Some(cond) = for_stmt.condition {
                    self.scan_expression(cond);
                }
                // Scan update expressions
                for update in for_stmt.update {
                    self.scan_expression(update);
                }
                // Scan body
                self.scan_statement(for_stmt.body);
            }
            Stmt::Foreach(foreach) => {
                // Scan iteration variable types
                // Skip auto types - resolved from iterable in function_processor
                for var in foreach.vars {
                    if !matches!(var.ty.base, TypeBase::Auto) {
                        self.resolve_type_expr(&var.ty);
                    }
                }
                // Scan the iterable expression
                self.scan_expression(foreach.expr);
                // Scan body
                self.scan_statement(foreach.body);
            }
            Stmt::Switch(switch) => {
                self.scan_expression(switch.expr);
                for case in switch.cases {
                    for value in case.values {
                        self.scan_expression(value);
                    }
                    for case_stmt in case.stmts {
                        self.scan_statement(case_stmt);
                    }
                }
            }
            Stmt::TryCatch(try_catch) => {
                self.scan_block(&try_catch.try_block);
                self.scan_block(&try_catch.catch_block);
            }
            Stmt::Break(_) | Stmt::Continue(_) => {
                // No types to scan
            }
        }
    }

    /// Scan an expression for type expressions (casts, lambdas, etc.)
    fn scan_expression(&mut self, expr: &Expr<'ast>) {
        match expr {
            Expr::Cast(cast) => {
                // Cast expressions have explicit target types
                let _ = self.resolve_type_expr(&cast.target_type);
                self.scan_expression(cast.expr);
            }
            Expr::Lambda(lambda) => {
                // Lambda parameters may have types
                for param in lambda.params {
                    if let Some(param_type) = &param.ty {
                        let _ = self.resolve_type_expr(&param_type.ty);
                    }
                }
                // Lambda return type
                if let Some(ret_type) = &lambda.return_type {
                    let _ = self.resolve_type_expr(&ret_type.ty);
                }
                // Scan lambda body
                self.scan_block(lambda.body);
            }
            Expr::InitList(init_list) => {
                // Init list may have explicit type annotation
                if let Some(ty) = &init_list.ty {
                    let _ = self.resolve_type_expr(ty);
                }
                // Scan elements
                for element in init_list.elements {
                    match element {
                        InitElement::Expr(e) => self.scan_expression(e),
                        InitElement::InitList(nested) => {
                            for nested_elem in nested.elements {
                                match nested_elem {
                                    InitElement::Expr(e) => self.scan_expression(e),
                                    InitElement::InitList(_) => {
                                        // Deeply nested - would need recursion
                                        // For now, assume 2 levels is enough
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Expr::Binary(binary) => {
                self.scan_expression(binary.left);
                self.scan_expression(binary.right);
            }
            Expr::Unary(unary) => {
                self.scan_expression(unary.operand);
            }
            Expr::Call(call) => {
                self.scan_expression(call.callee);
                for arg in call.args {
                    self.scan_expression(arg.value);
                }
            }
            Expr::Index(index) => {
                self.scan_expression(index.object);
                for idx in index.indices {
                    self.scan_expression(idx.index);
                }
            }
            Expr::Member(member) => {
                self.scan_expression(member.object);
            }
            Expr::Ternary(ternary) => {
                self.scan_expression(ternary.condition);
                self.scan_expression(ternary.then_expr);
                self.scan_expression(ternary.else_expr);
            }
            Expr::Paren(paren) => {
                self.scan_expression(paren.expr);
            }
            Expr::Assign(assign) => {
                self.scan_expression(assign.target);
                self.scan_expression(assign.value);
            }
            Expr::Postfix(postfix) => {
                self.scan_expression(postfix.operand);
            }
            // Leaf expressions - no nested types
            Expr::Literal(_) | Expr::Ident(_) => {}
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Parser;
    use crate::semantic::{Registrar, OperatorBehavior, TypeDef};
    use bumpalo::Bump;

    fn compile<'ast>(source: &str, arena: &'ast Bump) -> TypeCompilationData<'ast> {
        let (script, parse_errors) = Parser::parse_lenient(source, arena);
        assert!(parse_errors.is_empty(), "Parse errors: {:?}", parse_errors);

        // Pass 1: Registration
        let registration = Registrar::register(&script);
        assert!(registration.errors.is_empty(), "Registration errors: {:?}", registration.errors);

        // Pass 2a: Type compilation
        TypeCompiler::compile(&script, registration.registry)
    }

    #[test]
    fn empty_script() {
        let arena = Bump::new();
        let data = compile("", &arena);
        assert!(data.errors.is_empty());
    }

    #[test]
    fn resolve_primitive_type() {
        let arena = Bump::new();
        let data = compile("class Player { int health; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].name, "health");
            assert_eq!(fields[0].data_type.type_id, data.registry.int32_type);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_multiple_field_types() {
        let arena = Bump::new();
        let data = compile(r#"
            class Player {
                int health;
                float speed;
                bool isAlive;
                double score;
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 4);
            assert_eq!(fields[0].data_type.type_id, data.registry.int32_type);
            assert_eq!(fields[1].data_type.type_id, data.registry.float_type);
            assert_eq!(fields[2].data_type.type_id, data.registry.bool_type);
            assert_eq!(fields[3].data_type.type_id, data.registry.double_type);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_user_defined_type() {
        let arena = Bump::new();
        let data = compile(r#"
            class Position { int x; int y; }
            class Player { Position pos; }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let position_id = data.registry.lookup_type("Position").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].data_type.type_id, position_id);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_const_modifier() {
        let arena = Bump::new();
        let data = compile("class Player { const int maxHealth; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert!(fields[0].data_type.is_const);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_handle_modifier() {
        let arena = Bump::new();
        let data = compile(r#"
            class Item { }
            class Player { Item@ currentItem; }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert!(fields[0].data_type.is_handle);
            assert!(!fields[0].data_type.is_handle_to_const);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_const_handle() {
        let arena = Bump::new();
        let data = compile(r#"
            class Item { }
            class Player { const Item@ currentItem; }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert!(fields[0].data_type.is_handle);
            assert!(fields[0].data_type.is_handle_to_const);
        } else {
            panic!("Expected Class typedef");
        }
    }

    // Template tests will be added once Registry::instantiate_template is available

    #[test]
    fn operator_methods_registered() {
        let arena = Bump::new();
        let data = compile(r#"
            class Vector3 {
                float x;
                float y;
                float z;

                string opConv() const { return ""; }
                int opImplConv() const { return 0; }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let vector3_id = data.registry.lookup_type("Vector3").unwrap();
        let typedef = data.registry.get_type(vector3_id);

        if let TypeDef::Class { operator_methods, .. } = typedef {
            // Check opConv (explicit value conversion to string)
            let string_type_id = data.registry.string_type;
            let op_conv_behavior = OperatorBehavior::OpConv(string_type_id);
            assert!(operator_methods.contains_key(&op_conv_behavior),
                "opConv to string should be registered");

            // Check opImplConv (implicit value conversion to int)
            let int_type_id = data.registry.int32_type;
            let op_impl_conv_behavior = OperatorBehavior::OpImplConv(int_type_id);
            assert!(operator_methods.contains_key(&op_impl_conv_behavior),
                "opImplConv to int should be registered");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn operator_cast_methods_registered() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base { }
            class Derived : Base { }

            class Container {
                Base@ opCast() { }
                Derived@ opImplCast() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let container_id = data.registry.lookup_type("Container").unwrap();
        let base_id = data.registry.lookup_type("Base").unwrap();
        let derived_id = data.registry.lookup_type("Derived").unwrap();
        let typedef = data.registry.get_type(container_id);

        if let TypeDef::Class { operator_methods, .. } = typedef {
            // Check opCast (explicit handle cast to Base)
            let op_cast_behavior = OperatorBehavior::OpCast(base_id);
            assert!(operator_methods.contains_key(&op_cast_behavior),
                "opCast to Base@ should be registered");

            // Check opImplCast (implicit handle cast to Derived)
            let op_impl_cast_behavior = OperatorBehavior::OpImplCast(derived_id);
            assert!(operator_methods.contains_key(&op_impl_cast_behavior),
                "opImplCast to Derived@ should be registered");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn explicit_property_detection() {
        let arena = Bump::new();
        // Test that explicit property accessor methods are detected and mapped
        let data = compile(r#"
            class Player {
                private int _health;

                int get_health() const property {
                    return _health;
                }

                void set_health(int value) property {
                    _health = value;
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { properties, .. } = typedef {
            // Should have one property named "health"
            assert_eq!(properties.len(), 1, "Should have exactly one property");

            let health_prop = properties.get("health").expect("Should have 'health' property");
            assert!(health_prop.getter.is_some(), "Should have getter");
            assert!(health_prop.setter.is_some(), "Should have setter");

            // Verify getter is const
            let getter_func = data.registry.get_function(health_prop.getter.unwrap());
            assert!(getter_func.traits.is_const, "Getter must be const");
            assert_eq!(getter_func.name, "get_health");

            // Verify setter is not const
            let setter_func = data.registry.get_function(health_prop.setter.unwrap());
            assert!(!setter_func.traits.is_const, "Setter must not be const");
            assert_eq!(setter_func.name, "set_health");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn explicit_read_only_property() {
        let arena = Bump::new();
        // Test that read-only explicit properties work
        let data = compile(r#"
            class Player {
                private int _score;

                int get_score() const property {
                    return _score;
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { properties, .. } = typedef {
            let score_prop = properties.get("score").expect("Should have 'score' property");
            assert!(score_prop.getter.is_some(), "Should have getter");
            assert!(score_prop.setter.is_none(), "Should NOT have setter for read-only property");
            assert!(score_prop.is_read_only(), "Should be read-only");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn mixed_virtual_and_explicit_properties() {
        let arena = Bump::new();
        // Test that both virtual and explicit properties can coexist
        let data = compile(r#"
            class Player {
                private int _health;
                private int _score;

                // Virtual property
                int health {
                    get const { return _health; }
                    set { _health = value; }
                }

                // Explicit property
                int get_score() const property {
                    return _score;
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { properties, .. } = typedef {
            assert_eq!(properties.len(), 2, "Should have two properties");

            // Check virtual property
            let health_prop = properties.get("health").expect("Should have 'health' property");
            assert!(health_prop.getter.is_some());
            assert!(health_prop.setter.is_some());

            // Check explicit property
            let score_prop = properties.get("score").expect("Should have 'score' property");
            assert!(score_prop.getter.is_some());
            assert!(score_prop.setter.is_none());
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn field_visibility_public() {
        let arena = Bump::new();
        let data = compile("class Player { int health; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].visibility, Visibility::Public);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn field_visibility_private() {
        let arena = Bump::new();
        let data = compile("class Player { private int secret; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].visibility, Visibility::Private);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn field_visibility_protected() {
        let arena = Bump::new();
        let data = compile("class Player { protected int inherited; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].visibility, Visibility::Protected);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn typedef_creates_alias() {
        let arena = Bump::new();
        let data = compile("typedef float real;", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        // 'real' should resolve to the same type as 'float'
        let real_id = data.registry.lookup_type("real");
        let float_id = data.registry.lookup_type("float");

        assert!(real_id.is_some(), "typedef 'real' should be registered");
        assert_eq!(real_id, float_id, "typedef should point to same type as float");
    }

    #[test]
    fn typedef_in_namespace() {
        let arena = Bump::new();
        let data = compile("namespace Math { typedef double number; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let number_id = data.registry.lookup_type("Math::number");
        let double_id = data.registry.lookup_type("double");

        assert!(number_id.is_some(), "typedef 'Math::number' should be registered");
        assert_eq!(number_id, double_id, "typedef should point to same type as double");
    }

    #[test]
    fn array_suffix_instantiates_template() {
        let arena = Bump::new();
        let data = compile("class Container { int[] numbers; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let container_id = data.registry.lookup_type("Container").unwrap();
        let typedef = data.registry.get_type(container_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            // The field type should be array<int>@ (handle)
            assert!(fields[0].data_type.is_handle);

            // Check that it's an array template instance
            let field_type = data.registry.get_type(fields[0].data_type.type_id);
            assert!(field_type.is_template_instance(), "Field type should be array<int>");
        } else {
            panic!("Expected Class typedef");
        }
    }

    // ========================================================================
    // Interface Implementation Validation Tests
    // ========================================================================

    #[test]
    fn interface_implementation_complete() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
                int getWidth();
            }

            class Widget : IDrawable {
                void draw() { }
                int getWidth() { return 0; }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);
    }

    #[test]
    fn interface_method_missing_error() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
                int getWidth();
            }

            class Widget : IDrawable {
                void draw() { }
                // Missing: int getWidth()
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing interface method");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("getWidth"));
    }

    #[test]
    fn interface_method_wrong_signature_error() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                int getWidth();
            }

            class Widget : IDrawable {
                // Wrong return type (void instead of int)
                void getWidth() { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for wrong signature");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
    }

    #[test]
    fn abstract_class_partial_interface_ok() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
                int getWidth();
            }

            abstract class AbstractWidget : IDrawable {
                // Only implements one method - OK because abstract
                void draw() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Abstract class should not need to implement all interface methods. Errors: {:?}", data.errors);
    }

    #[test]
    fn interface_method_inherited_from_base() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            class BaseWidget : IDrawable {
                void draw() { }
            }

            class DerivedWidget : BaseWidget {
                // Inherits draw() from BaseWidget, so interface is satisfied
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Interface method inherited from base should satisfy requirement. Errors: {:?}", data.errors);
    }

    #[test]
    fn multiple_interfaces_all_implemented() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            interface IClickable {
                void onClick();
            }

            class Button : IDrawable, IClickable {
                void draw() { }
                void onClick() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "All interface methods implemented. Errors: {:?}", data.errors);
    }

    #[test]
    fn multiple_interfaces_one_missing() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            interface IClickable {
                void onClick();
            }

            class Button : IDrawable, IClickable {
                void draw() { }
                // Missing: onClick()
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing onClick");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("onClick"));
    }

    #[test]
    fn abstract_class_defers_interface_to_concrete_subclass() {
        // Abstract class implements interface but defers implementation to concrete subclass
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            abstract class Widget : IDrawable {
                // Abstract class doesn't implement draw() - OK, defers to subclass
            }

            class Button : Widget {
                void draw() { }  // Concrete class provides implementation
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Abstract class can defer interface to concrete subclass. Errors: {:?}", data.errors);
    }

    #[test]
    fn concrete_class_missing_inherited_interface_method() {
        // Concrete class inherits from abstract class that implements interface,
        // but doesn't provide the implementation
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            abstract class Widget : IDrawable {
                // Abstract class doesn't implement draw()
            }

            class Button : Widget {
                // Concrete class ALSO doesn't implement draw() - ERROR!
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing interface method");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("draw"));
    }

    #[test]
    fn abstract_class_chain_with_interface() {
        // Chain of abstract classes, only the final concrete one needs to implement
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            abstract class Widget : IDrawable { }

            abstract class ClickableWidget : Widget { }

            class Button : ClickableWidget {
                void draw() { }  // Finally implemented here
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Chain of abstract classes, implementation at end. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_class_chain_multiple_interfaces_all_implemented() {
        // Abstract class chain with multiple interfaces at different levels
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            interface IClickable {
                void onClick();
            }

            interface IFocusable {
                void onFocus();
            }

            abstract class Widget : IDrawable { }

            abstract class InteractiveWidget : Widget, IClickable, IFocusable { }

            class Button : InteractiveWidget {
                void draw() { }      // From IDrawable (on Widget)
                void onClick() { }   // From IClickable (on InteractiveWidget)
                void onFocus() { }   // From IFocusable (on InteractiveWidget)
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Concrete class implements all inherited interfaces. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_class_chain_multiple_interfaces_one_missing() {
        // Abstract class chain with multiple interfaces, but concrete class misses one
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            interface IClickable {
                void onClick();
            }

            interface IFocusable {
                void onFocus();
            }

            abstract class Widget : IDrawable { }

            abstract class InteractiveWidget : Widget, IClickable, IFocusable { }

            class Button : InteractiveWidget {
                void draw() { }      // From IDrawable (on Widget)
                void onClick() { }   // From IClickable (on InteractiveWidget)
                // Missing: onFocus() from IFocusable
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing onFocus");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("onFocus"));
    }

    #[test]
    fn abstract_class_partial_implementation() {
        // Abstract class implements some interface methods, concrete class must implement the rest
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class BaseWidget : IWidget {
                void draw() { }  // Abstract class implements draw()
                // But leaves update() for concrete class
            }

            class Button : BaseWidget {
                void update() { }  // Concrete class implements update()
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Abstract class partial implementation completed by concrete. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_class_final_method_cannot_be_overridden() {
        // Abstract class implements interface method as final, concrete subclass cannot override
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
            }

            abstract class BaseWidget : IWidget {
                void draw() final { }  // Abstract class implements draw() as final
            }

            class Button : BaseWidget {
                void draw() { }  // ERROR: Cannot override final method
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(data.errors[0].message.contains("draw"));
    }

    #[test]
    fn abstract_class_chain_final_method_in_middle() {
        // Final method in middle of abstract class chain
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class Widget : IWidget {
                void draw() final { }  // Widget implements draw() as final
                // update() left for subclasses
            }

            abstract class ClickableWidget : Widget {
                // Cannot override draw() here either - it's final from Widget
            }

            class Button : ClickableWidget {
                void update() { }   // OK: implement update()
                void draw() { }     // ERROR: Cannot override final from Widget
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method from abstract grandparent");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(data.errors[0].message.contains("draw"));
    }

    #[test]
    fn abstract_class_chain_final_method_not_overridden_ok() {
        // Final method in abstract class, concrete subclass doesn't try to override - OK
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class BaseWidget : IWidget {
                void draw() final { }  // Abstract class implements draw() as final
                // update() left for subclasses
            }

            class Button : BaseWidget {
                void update() { }  // Only implement update(), draw() is final from base
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Not overriding final method is OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_chain_with_final_method_and_intermediate_abstract() {
        // Abstract class chain: BaseWidget (final draw) -> MiddleWidget -> Button
        // Button should NOT be able to override draw() even with an intermediate abstract class
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class BaseWidget : IWidget {
                void draw() final { }  // Abstract class implements draw() as final
                // update() left for subclasses
            }

            abstract class MiddleWidget : BaseWidget {
                // MiddleWidget is abstract, doesn't implement update()
                // Cannot override draw() here either since it's final
            }

            class Button : MiddleWidget {
                void update() { }   // OK: implement update()
                void draw() { }     // ERROR: Cannot override final from BaseWidget (through MiddleWidget)
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method from grandparent abstract class");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(data.errors[0].message.contains("draw"));
    }

    #[test]
    fn abstract_chain_with_final_method_not_overridden_ok() {
        // Same chain but concrete class doesn't try to override the final method - OK
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class BaseWidget : IWidget {
                void draw() final { }  // Abstract class implements draw() as final
            }

            abstract class MiddleWidget : BaseWidget {
                // Doesn't override draw() (it's final)
                // Doesn't implement update() (still abstract)
            }

            class Button : MiddleWidget {
                void update() { }   // Only implement update()
                // draw() is final from BaseWidget - we don't try to override
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Not overriding final method through intermediate is OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_chain_with_interface_and_multiple_intermediate_abstracts() {
        // Deep chain: IWidget -> BaseWidget -> MiddleWidget -> ConcreteButton
        // where interface method is NOT implemented until concrete class
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
            }

            abstract class BaseWidget : IWidget {
                // Doesn't implement draw() - defers to subclass
            }

            abstract class MiddleWidget : BaseWidget {
                // Still doesn't implement draw() - defers to subclass
            }

            class ConcreteButton : MiddleWidget {
                void draw() { }   // Finally implements draw() here
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Concrete class implements interface method through deep chain. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_chain_with_interface_missing_implementation() {
        // Deep chain where no class implements the interface method - ERROR on concrete
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
            }

            abstract class BaseWidget : IWidget {
                // Doesn't implement draw()
            }

            abstract class MiddleWidget : BaseWidget {
                // Doesn't implement draw()
            }

            class ConcreteButton : MiddleWidget {
                // MISSING: draw() - ERROR!
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing interface method");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("draw"));
    }

    // ========================================================================
    // Override Keyword Validation Tests
    // ========================================================================

    #[test]
    fn override_keyword_valid() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() { }
            }

            class Derived : Base {
                void update() override { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Valid override should not produce errors. Errors: {:?}", data.errors);
    }

    #[test]
    fn override_keyword_no_base_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() { }
            }

            class Derived : Base {
                // 'override' but no matching base method (wrong name)
                void render() override { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for override without base method");
        assert!(data.errors[0].kind == SemanticErrorKind::OverrideWithoutBase);
        assert!(data.errors[0].message.contains("render"));
    }

    #[test]
    fn override_wrong_signature_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() { }
            }

            class Derived : Base {
                // 'override' but wrong parameter signature
                void update(int x) override { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for override with wrong signature");
        assert!(data.errors[0].kind == SemanticErrorKind::OverrideWithoutBase);
    }

    // ========================================================================
    // Final Method Validation Tests
    // ========================================================================

    #[test]
    fn final_method_not_overridden() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() final { }
            }

            class Derived : Base {
                // No override of final method - OK
                void render() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Not overriding final method should be OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn override_final_method_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() final { }
            }

            class Derived : Base {
                // Trying to override a final method
                void update() { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(data.errors[0].message.contains("update"));
    }

    #[test]
    fn override_final_method_with_override_keyword_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() final { }
            }

            class Derived : Base {
                // Trying to override a final method with override keyword
                void update() override { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method");
        // Should have CannotOverrideFinal error
        let has_final_error = data.errors.iter()
            .any(|e| e.kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(has_final_error, "Should have CannotOverrideFinal error. Errors: {:?}", data.errors);
    }

    #[test]
    fn grandparent_final_method_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class GrandParent {
                void update() final { }
            }

            class Parent : GrandParent {
                // No override here
            }

            class Child : Parent {
                // Trying to override grandparent's final method
                void update() { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding grandparent's final method");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
    }

    // ========================================================================
    // Final Class Validation Tests
    // ========================================================================

    #[test]
    fn inherit_from_non_final_class_ok() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base { }

            class Derived : Base { }
        "#, &arena);
        assert!(data.errors.is_empty(), "Inheriting from non-final class should be OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn inherit_from_final_class_error() {
        let arena = Bump::new();
        let data = compile(r#"
            final class Sealed { }

            class Derived : Sealed { }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for inheriting from final class");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotInheritFromFinal);
        assert!(data.errors[0].message.contains("Sealed"));
    }

    #[test]
    fn abstract_class_can_be_inherited() {
        let arena = Bump::new();
        let data = compile(r#"
            abstract class AbstractBase { }

            class Concrete : AbstractBase { }
        "#, &arena);
        assert!(data.errors.is_empty(), "Inheriting from abstract class should be OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn final_class_can_implement_interface() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
            }

            final class Button : IWidget {
                void draw() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Final class implementing interface should be OK. Errors: {:?}", data.errors);
    }

    // ========================================================================
    // Mixin Tests
    // ========================================================================

    #[test]
    fn mixin_basic_method() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                void mixinMethod() { }
            }

            class MyClass : MyMixin {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Basic mixin should compile. Errors: {:?}", data.errors);

        // Verify the class got the mixin method
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let methods = data.registry.get_methods(class_id);
        let method_names: Vec<&str> = methods.iter()
            .map(|&id| data.registry.get_function(id).name.as_str())
            .collect();
        assert!(method_names.contains(&"mixinMethod"), "Class should have mixinMethod from mixin. Methods: {:?}", method_names);
    }

    #[test]
    fn mixin_basic_field() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                int mixinField;
            }

            class MyClass : MyMixin {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Mixin with field should compile. Errors: {:?}", data.errors);

        // Verify the class got the mixin field
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let fields = data.registry.get_class_fields(class_id);
        let field_names: Vec<&str> = fields.iter()
            .map(|f| f.name.as_str())
            .collect();
        assert!(field_names.contains(&"mixinField"), "Class should have mixinField from mixin. Fields: {:?}", field_names);
    }

    #[test]
    fn mixin_class_method_overrides_mixin() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                void update() { }
            }

            class MyClass : MyMixin {
                void update() { }  // Class-defined method should override mixin
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Class method should override mixin method. Errors: {:?}", data.errors);

        // Verify we only have one update method, not two
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let methods = data.registry.get_methods(class_id);
        let update_count = methods.iter()
            .filter(|&&id| data.registry.get_function(id).name == "update")
            .count();
        assert_eq!(update_count, 1, "Should have exactly one update method (class overrides mixin)");
    }

    #[test]
    fn mixin_field_not_duplicated() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                int health;
            }

            class MyClass : MyMixin {
                int health;  // Class field should override mixin field
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Class field should override mixin field. Errors: {:?}", data.errors);

        // Verify we only have one health field
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let fields = data.registry.get_class_fields(class_id);
        let health_count = fields.iter()
            .filter(|f| f.name == "health")
            .count();
        assert_eq!(health_count, 1, "Should have exactly one health field");
    }

    #[test]
    fn mixin_with_interface() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            mixin class DrawableMixin : IDrawable {
                void draw() { }
            }

            class Widget : DrawableMixin {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Mixin with interface should compile. Errors: {:?}", data.errors);

        // Verify the class implements the interface
        let class_id = data.registry.lookup_type("Widget").expect("Widget not found");
        let typedef = data.registry.get_type(class_id);
        if let crate::semantic::TypeDef::Class { interfaces, .. } = typedef {
            let iface_id = data.registry.lookup_type("IDrawable").expect("IDrawable not found");
            assert!(interfaces.contains(&iface_id), "Widget should implement IDrawable from mixin");
        } else {
            panic!("Widget should be a class");
        }
    }

    #[test]
    fn multiple_mixins() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MixinA {
                void methodA() { }
            }

            mixin class MixinB {
                void methodB() { }
            }

            class MyClass : MixinA, MixinB {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Multiple mixins should compile. Errors: {:?}", data.errors);

        // Verify the class got both methods
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let methods = data.registry.get_methods(class_id);
        let method_names: Vec<&str> = methods.iter()
            .map(|&id| data.registry.get_function(id).name.as_str())
            .collect();
        assert!(method_names.contains(&"methodA"), "Should have methodA. Methods: {:?}", method_names);
        assert!(method_names.contains(&"methodB"), "Should have methodB. Methods: {:?}", method_names);
    }

    #[test]
    fn mixin_with_base_class() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void baseMethod() { }
            }

            mixin class MyMixin {
                void mixinMethod() { }
            }

            class Derived : Base, MyMixin {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Class with base and mixin should compile. Errors: {:?}", data.errors);

        // Verify the class has the mixin method
        let class_id = data.registry.lookup_type("Derived").expect("Derived not found");
        let methods = data.registry.get_methods(class_id);
        let method_names: Vec<&str> = methods.iter()
            .map(|&id| data.registry.get_function(id).name.as_str())
            .collect();
        assert!(method_names.contains(&"mixinMethod"), "Should have mixinMethod. Methods: {:?}", method_names);
    }

    #[test]
    fn mixin_is_not_a_type() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                void method() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Mixin declaration should compile. Errors: {:?}", data.errors);

        // Verify the mixin is not registered as a type
        assert!(data.registry.lookup_type("MyMixin").is_none(), "Mixin should not be registered as a type");
        // But it should be registered as a mixin
        assert!(data.registry.is_mixin("MyMixin"), "MyMixin should be registered as a mixin");
    }

    // ==================== Void Expression Validation Tests ====================

    #[test]
    fn void_class_field_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class MyClass {
                void badField;
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should fail for void class field");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::VoidExpression
                && e.message.contains("cannot declare field")
                && e.message.contains("of type 'void'")
        }), "Should have VoidExpression error: {:?}", data.errors);
    }

    // Note: void_function_parameter_error and void_method_parameter_error tests are not included
    // because AngelScript's syntax doesn't allow `void param_name` - the parser rejects this.
    // The semantic validation is still in place as defensive programming for programmatic AST creation.

    // ==================== Circular Inheritance Detection Tests ====================

    #[test]
    fn circular_inheritance_direct_self() {
        // class A : A {} - direct self-inheritance
        let arena = Bump::new();
        let data = compile(r#"
            class A : A {
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should fail for self-inheritance");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::CircularInheritance
        }), "Should have CircularInheritance error: {:?}", data.errors);
    }

    #[test]
    fn circular_inheritance_two_classes() {
        // class A : B {}, class B : A {} - indirect cycle
        let arena = Bump::new();
        let data = compile(r#"
            class A : B {
            }
            class B : A {
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should fail for circular inheritance");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::CircularInheritance
        }), "Should have CircularInheritance error: {:?}", data.errors);
    }

    #[test]
    fn circular_inheritance_three_classes() {
        // class A : B {}, class B : C {}, class C : A {} - longer cycle
        let arena = Bump::new();
        let data = compile(r#"
            class A : B {
            }
            class B : C {
            }
            class C : A {
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should fail for circular inheritance");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::CircularInheritance
        }), "Should have CircularInheritance error: {:?}", data.errors);
    }

    #[test]
    fn valid_linear_inheritance() {
        // Valid: class A {}, class B : A {}, class C : B {}
        let arena = Bump::new();
        let data = compile(r#"
            class A {
            }
            class B : A {
            }
            class C : B {
            }
        "#, &arena);

        assert!(data.errors.is_empty(), "Valid linear inheritance should not produce errors: {:?}", data.errors);
    }

    #[test]
    fn circular_inheritance_error_message() {
        let arena = Bump::new();
        let data = compile(r#"
            class Foo : Foo {
            }
        "#, &arena);

        let error = data.errors.iter().find(|e| e.kind == SemanticErrorKind::CircularInheritance);
        assert!(error.is_some(), "Should have CircularInheritance error");

        let error = error.unwrap();
        assert!(error.message.contains("circular inheritance detected"), "Error message should mention circular inheritance: {}", error.message);
        assert!(error.message.contains("Foo"), "Error message should mention the class name: {}", error.message);
    }

    #[test]
    fn auto_type_not_supported() {
        let arena = Bump::new();
        let data = compile(r#"
            class Player {
                auto x;
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should produce an error for auto type");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::UndefinedType &&
            e.message.contains("auto type inference not yet supported")
        }), "Should have auto type error: {:?}", data.errors);
    }

    #[test]
    fn unknown_type() {
        let arena = Bump::new();
        let data = compile(r#"
            class Player {
                ? x;
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should produce an error for unknown type");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::UndefinedType &&
            e.message.contains("unknown type '?'")
        }), "Should have unknown type error: {:?}", data.errors);
    }

    #[test]
    fn void_field_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Player {
                void x;
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should produce an error for void field");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::VoidExpression &&
            e.message.contains("cannot declare field") &&
            e.message.contains("void")
        }), "Should have void field error: {:?}", data.errors);
    }

    #[test]
    fn undefined_base_class() {
        let arena = Bump::new();
        let data = compile(r#"
            class Player : UndefinedBaseClass {
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should produce an error for undefined base class");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::UndefinedType
        }), "Should have undefined type error: {:?}", data.errors);
    }

    #[test]
    fn inherit_from_non_class_type() {
        let arena = Bump::new();
        let data = compile(r#"
            enum Color { Red, Green, Blue }
            class Player : Color {
            }
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should produce an error for inheriting from enum");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::UndefinedType &&
            e.message.contains("not a class or interface")
        }), "Should have type error: {:?}", data.errors);
    }

    #[test]
    fn const_handle_to_const() {
        // Test const T@ semantics - the const moves to handle_to_const
        let arena = Bump::new();
        let data = compile(r#"
            class Item { }
            class Player { const Item@ item; }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert!(fields[0].data_type.is_handle);
            assert!(fields[0].data_type.is_handle_to_const);
            // const should have been moved to handle_to_const
            assert!(!fields[0].data_type.is_const);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn array_suffix_syntax() {
        // Test T[] syntax creates array<T>
        let arena = Bump::new();
        let data = compile(r#"
            class Player {
                int[] scores;
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            // Array types are handles
            assert!(fields[0].data_type.is_handle);
            // Should be a template instance (array<int>)
            let field_type = data.registry.get_type(fields[0].data_type.type_id);
            assert!(field_type.is_template_instance());
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn typedef_alias() {
        let arena = Bump::new();
        let data = compile(r#"
            typedef float real;
            class Player {
                real speed;
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            // The field type should resolve to float
            assert_eq!(fields[0].data_type.type_id, data.registry.float_type);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn typedef_undefined_base_type() {
        let arena = Bump::new();
        let data = compile(r#"
            typedef UndefinedType mytype;
        "#, &arena);

        assert!(!data.errors.is_empty(), "Should produce an error for undefined base type");
        assert!(data.errors.iter().any(|e| {
            e.kind == SemanticErrorKind::UndefinedType
        }), "Should have undefined type error: {:?}", data.errors);
    }

    #[test]
    fn funcdef_with_params() {
        let arena = Bump::new();
        let data = compile(r#"
            funcdef int Callback(int x, float y);
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let callback_id = data.registry.lookup_type("Callback").unwrap();
        let typedef = data.registry.get_type(callback_id);

        if let TypeDef::Funcdef { params, return_type, .. } = typedef {
            assert_eq!(params.len(), 2);
            assert_eq!(params[0].type_id, data.registry.int32_type);
            assert_eq!(params[1].type_id, data.registry.float_type);
            assert_eq!(return_type.type_id, data.registry.int32_type);
        } else {
            panic!("Expected Funcdef typedef");
        }
    }

    #[test]
    fn interface_method_signatures() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw(int x, int y);
                int getWidth() const;
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let drawable_id = data.registry.lookup_type("IDrawable").unwrap();
        let typedef = data.registry.get_type(drawable_id);

        if let TypeDef::Interface { methods, .. } = typedef {
            assert_eq!(methods.len(), 2);
            // Check draw method
            let draw_method = methods.iter().find(|m| m.name == "draw").unwrap();
            assert_eq!(draw_method.params.len(), 2);
            // Check getWidth method
            let get_width = methods.iter().find(|m| m.name == "getWidth").unwrap();
            assert_eq!(get_width.params.len(), 0);
        } else {
            panic!("Expected Interface typedef");
        }
    }

    #[test]
    fn class_implementing_interface() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }
            class Widget : IDrawable {
                void draw() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let widget_id = data.registry.lookup_type("Widget").unwrap();
        let drawable_id = data.registry.lookup_type("IDrawable").unwrap();
        let typedef = data.registry.get_type(widget_id);

        if let TypeDef::Class { interfaces, .. } = typedef {
            assert!(interfaces.contains(&drawable_id), "Widget should implement IDrawable");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn global_variable_registration() {
        let arena = Bump::new();
        let data = compile(r#"
            int globalCounter;
            float globalSpeed = 1.0f;
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        // Global variables should be registered
        // Note: The exact API depends on the Registry implementation
        // This test ensures the code path is exercised
    }

    #[test]
    fn namespace_types() {
        let arena = Bump::new();
        let data = compile(r#"
            namespace Game {
                class Player { int health; }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        // Look up type with namespace
        let player_id = data.registry.lookup_type("Game::Player").unwrap();
        let typedef = data.registry.get_type(player_id);
        assert!(typedef.is_class());
    }

    #[test]
    fn nested_namespace() {
        let arena = Bump::new();
        let data = compile(r#"
            namespace Game::World {
                class Entity { int id; }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        // Look up type with nested namespace
        let entity_id = data.registry.lookup_type("Game::World::Entity").unwrap();
        let typedef = data.registry.get_type(entity_id);
        assert!(typedef.is_class());
    }

    #[test]
    fn scoped_type_reference() {
        let arena = Bump::new();
        let data = compile(r#"
            namespace Lib {
                class Vector { float x; float y; }
            }
            class Player {
                Lib::Vector position;
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let vector_id = data.registry.lookup_type("Lib::Vector").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].data_type.type_id, vector_id);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn field_visibility() {
        // Note: AngelScript visibility is declared differently, using sections
        // Here we test the visibility handling paths with existing supported syntax
        let arena = Bump::new();
        let data = compile(r#"
            class Player {
                int publicField;
                private int privateField;
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 2);

            let public_field = fields.iter().find(|f| f.name == "publicField").unwrap();
            assert_eq!(public_field.visibility, Visibility::Public);

            let private_field = fields.iter().find(|f| f.name == "privateField").unwrap();
            assert_eq!(private_field.visibility, Visibility::Private);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn template_instantiation() {
        let arena = Bump::new();
        let data = compile(r#"
            class Container {
                array<int> items;
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let container_id = data.registry.lookup_type("Container").unwrap();
        let typedef = data.registry.get_type(container_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            // The field should be a template instance
            let field_type = data.registry.get_type(fields[0].data_type.type_id);
            assert!(field_type.is_template_instance());
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn method_return_type_resolution() {
        let arena = Bump::new();
        let data = compile(r#"
            class Player {
                string getName() { return ""; }
                int getHealth() { return 0; }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { methods, .. } = typedef {
            // Find getName method and check return type
            for method_id in methods {
                let func = data.registry.get_function(*method_id);
                if func.name == "getName" {
                    assert_eq!(func.return_type.type_id, data.registry.string_type);
                } else if func.name == "getHealth" {
                    assert_eq!(func.return_type.type_id, data.registry.int32_type);
                }
            }
        } else {
            panic!("Expected Class typedef");
        }
    }
}
