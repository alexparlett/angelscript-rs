//! Pass 2a: Type Compilation - Fill in all type details and resolve type expressions.
//!
//! This module implements the second pass of semantic analysis which takes the Registry
//! from Pass 1 (with registered names as empty shells) and fills in all type details.
//!
//! # What Pass 2a Does
//!
//! - Resolve all TypeExpr AST nodes → DataType
//! - Fill in class details (fields, methods, inheritance)
//! - Instantiate template types with caching
//! - Register complete function signatures
//! - Build type hierarchy (inheritance, interfaces)
//!
//! # What Pass 2a Does NOT Do
//!
//! - Does NOT track local variables (that's Pass 2b)
//! - Does NOT type check function bodies (that's Pass 2b)
//! - Does NOT generate bytecode (that's Pass 2b)
//!
//! # Example
//!
//! ```ignore
//! use angelscript::{parse_lenient, Registrar, TypeCompiler};
//! use bumpalo::Bump;
//!
//! let arena = Bump::new();
//! let source = r#"
//!     class Player {
//!         int health;
//!         array<string> items;
//!     }
//! "#;
//! let (script, _) = parse_lenient(source, &arena);
//!
//! // Pass 1: Registration
//! let registration = Registrar::register(&script);
//!
//! // Pass 2a: Type compilation
//! let type_compilation = TypeCompiler::compile(&script, registration.registry);
//! assert!(type_compilation.errors.is_empty());
//! ```

use crate::semantic::error::{SemanticError, SemanticErrorKind};
use crate::semantic::types::{
    data_type::{DataType, RefModifier},
    registry::Registry,
    type_def::{AutoGeneratedMethod, FieldDef, FunctionId, FunctionTraits, MethodSignature, OperatorBehavior, TypeDef, TypeId, Visibility},
};
use crate::ast::decl::{
    ClassDecl, ClassMember, EnumDecl, FuncdefDecl, FunctionDecl, GlobalVarDecl,
    InterfaceDecl, InterfaceMethod, Item, NamespaceDecl, TypedefDecl,
};
use crate::ast::expr::Expr;
use crate::ast::types::{PrimitiveType, TypeBase, TypeExpr, TypeSuffix};
use crate::ast::Script;
use crate::lexer::Span;
use rustc_hash::FxHashMap;

/// Output from Pass 2a: Type Compilation
#[derive(Debug)]
pub struct TypeCompilationData<'src, 'ast> {
    /// Registry with complete type information
    pub registry: Registry<'src, 'ast>,

    /// Maps AST TypeExpr spans to resolved DataType
    pub type_map: FxHashMap<Span, DataType>,

    /// Errors found during type compilation
    pub errors: Vec<SemanticError>,
}

/// Pass 2a: Type Compilation visitor
///
/// Walks the AST and fills in all type details in the Registry.
pub struct TypeCompiler<'src, 'ast> {
    /// The registry we're filling in
    registry: Registry<'src, 'ast>,

    /// Maps AST spans to resolved types
    type_map: FxHashMap<Span, DataType>,

    /// Current namespace path (e.g., ["Game", "World"])
    namespace_path: Vec<String>,

    /// Errors found during compilation
    errors: Vec<SemanticError>,

    /// Phantom markers
    _phantom: std::marker::PhantomData<(&'src str, &'ast ())>,
}

impl<'src, 'ast> TypeCompiler<'src, 'ast> {
    /// Create a new type compiler
    fn new(registry: Registry<'src, 'ast>) -> Self {
        Self {
            registry,
            type_map: FxHashMap::default(),
            namespace_path: Vec::new(),
            errors: Vec::new(),
            _phantom: std::marker::PhantomData,
        }
    }

    /// Perform Pass 2a type compilation on a script
    pub fn compile(
        script: &Script<'src, 'ast>,
        registry: Registry<'src, 'ast>,
    ) -> TypeCompilationData<'src, 'ast> {
        let mut compiler = Self::new(registry);
        compiler.visit_script(script);

        TypeCompilationData {
            registry: compiler.registry,
            type_map: compiler.type_map,
            errors: compiler.errors,
        }
    }

    /// Visit the entire script
    fn visit_script(&mut self, script: &Script<'src, 'ast>) {
        for item in script.items() {
            self.visit_item(item);
        }
    }

    /// Visit a top-level item
    fn visit_item(&mut self, item: &Item<'src, 'ast>) {
        match item {
            Item::Function(func) => self.visit_function(func, None),
            Item::Class(class) => self.visit_class(class),
            Item::Interface(iface) => self.visit_interface(iface),
            Item::Enum(enum_decl) => self.visit_enum(enum_decl),
            Item::GlobalVar(var) => self.visit_global_var(var),
            Item::Namespace(ns) => self.visit_namespace(ns),
            Item::Typedef(typedef) => self.visit_typedef(typedef),
            Item::Funcdef(funcdef) => self.visit_funcdef(funcdef),
            Item::Mixin(_) | Item::Import(_) => {
                // Skip mixins and imports for now
            }
        }
    }

    /// Visit a function declaration and fill in its signature
    fn visit_function(&mut self, func: &FunctionDecl<'src, 'ast>, object_type: Option<TypeId>) {
        let qualified_name = self.build_qualified_name(func.name.name);

        // Resolve parameter types
        let params: Vec<DataType> = func
            .params
            .iter()
            .filter_map(|p| self.resolve_type_expr(&p.ty.ty))
            .collect();

        // Check if we got all params (if any failed to resolve, we already logged errors)
        if params.len() != func.params.len() {
            // Some params failed to resolve, skip this function
            return;
        }

        // Resolve return type (default to void if None, e.g., for constructors)
        let return_type = if let Some(ret_ty) = func.return_type {
            match self.resolve_type_expr(&ret_ty.ty) {
                Some(dt) => dt,
                None => return, // Error already logged
            }
        } else {
            // Constructor or destructor - use void type
            DataType::simple(self.registry.void_type)
        };

        // Build function traits from AST
        let is_constructor = func.is_constructor();
        let is_destructor = func.is_destructor;
        let is_const = func.is_const;
        let is_explicit = func.attrs.explicit;
        // Method-level 'final' is in attrs, not modifiers (modifiers.final_ is for class-level)
        let is_final = func.attrs.final_;
        let is_virtual = object_type.is_some() && !is_final && !is_constructor && !is_destructor;
        // A function is abstract if it has no body (pure virtual)
        let is_abstract = func.body.is_none() && is_virtual;

        let traits = FunctionTraits {
            is_constructor,
            is_destructor,
            is_final,
            is_virtual,
            is_abstract,
            is_const,
            is_explicit,
            auto_generated: None,  // User-defined functions from AST are not auto-generated
        };

        // Capture default arguments from AST
        let default_args: Vec<Option<&'ast Expr<'src, 'ast>>> = func
            .params
            .iter()
            .map(|p| p.default)
            .collect();

        // Update the function signature in the registry
        self.registry.update_function_signature(&qualified_name, params, return_type, object_type, traits, default_args);
    }

    /// Visit a class declaration and fill in its details
    fn visit_class(&mut self, class: &ClassDecl<'src, 'ast>) {
        let qualified_name = self.build_qualified_name(class.name.name);

        // Look up the class type (registered in Pass 1)
        let type_id = match self.registry.lookup_type(&qualified_name) {
            Some(id) => id,
            None => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    class.span,
                    format!("class '{}' was not registered in Pass 1", qualified_name),
                ));
                return;
            }
        };

        // Resolve base class, interfaces, and mixins from inheritance list
        // In AngelScript, the first item in inheritance is the base class (if it's a class),
        // remaining items are interfaces or mixins
        let mut base_class = None;
        let mut interfaces = Vec::new();
        let mut mixins = Vec::new();

        for (i, inherited_ident) in class.inheritance.iter().enumerate() {
            // Look up the type or mixin
            let inherited_name = self.build_qualified_name(inherited_ident.name);

            // First check if it's a mixin
            if self.registry.is_mixin(&inherited_name) {
                mixins.push(inherited_name);
                continue;
            }

            if let Some(inherited_id) = self.registry.lookup_type(&inherited_name) {
                let inherited_typedef = self.registry.get_type(inherited_id);

                // First item can be a base class (if it's a class type)
                if i == 0 && inherited_typedef.is_class() {
                    // Check that base class is not final
                    if self.registry.is_class_final(inherited_id) {
                        self.errors.push(SemanticError::new(
                            SemanticErrorKind::CannotInheritFromFinal,
                            inherited_ident.span,
                            format!("cannot inherit from final class '{}'", inherited_name),
                        ));
                    }
                    base_class = Some(inherited_id);
                } else if inherited_typedef.is_interface() {
                    interfaces.push(inherited_id);
                } else if i == 0 {
                    // First item is not a class or interface
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::UndefinedType,
                        inherited_ident.span,
                        format!("'{}' is not a class or interface", inherited_name),
                    ));
                }
            } else {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    inherited_ident.span,
                    format!("undefined type '{}'", inherited_name),
                ));
            }
        }

        // Process mixins: add their interfaces, methods, and fields
        // Mixins must be processed before we collect class methods/fields
        for mixin_name in &mixins {
            if let Some(mixin) = self.registry.lookup_mixin(mixin_name) {
                // Add interfaces required by the mixin
                for iface_name in &mixin.required_interfaces {
                    if let Some(iface_id) = self.registry.lookup_type(iface_name) {
                        if !interfaces.contains(&iface_id) {
                            interfaces.push(iface_id);
                        }
                    }
                }
            }
        }

        // Collect the names of methods and fields defined in this class
        // These take precedence over mixin members
        let class_method_names: std::collections::HashSet<&str> = class.members
            .iter()
            .filter_map(|m| {
                if let ClassMember::Method(method) = m {
                    Some(method.name.name)
                } else {
                    None
                }
            })
            .collect();

        let class_field_names: std::collections::HashSet<&str> = class.members
            .iter()
            .filter_map(|m| {
                if let ClassMember::Field(field) = m {
                    Some(field.name.name)
                } else {
                    None
                }
            })
            .collect();

        // Resolve field types from class definition
        let mut fields = Vec::new();
        for member in class.members {
            if let ClassMember::Field(field) = member
                && let Some(field_type) = self.resolve_type_expr(&field.ty) {
                    // Convert AST visibility to semantic visibility
                    let visibility = match field.visibility {
                        crate::ast::Visibility::Public => Visibility::Public,
                        crate::ast::Visibility::Private => Visibility::Private,
                        crate::ast::Visibility::Protected => Visibility::Protected,
                    };
                    fields.push(FieldDef {
                        name: field.name.name.to_string(),
                        data_type: field_type,
                        visibility,
                    });
                }
        }

        // Add fields from mixins that don't conflict with class fields or inherited fields
        // Mixin fields are NOT added if already inherited from base class
        let inherited_field_names: std::collections::HashSet<String> = if let Some(base_id) = base_class {
            self.registry.get_class_fields(base_id)
                .iter()
                .map(|f| f.name.clone())
                .collect()
        } else {
            std::collections::HashSet::new()
        };

        for mixin_name in &mixins {
            if let Some(mixin) = self.registry.lookup_mixin(mixin_name) {
                for member in mixin.members {
                    if let ClassMember::Field(field) = member {
                        let field_name = field.name.name;
                        // Skip if already defined in class or inherited from base
                        if class_field_names.contains(field_name) || inherited_field_names.contains(field_name) {
                            continue;
                        }
                        if let Some(field_type) = self.resolve_type_expr(&field.ty) {
                            let visibility = match field.visibility {
                                crate::ast::Visibility::Public => Visibility::Public,
                                crate::ast::Visibility::Private => Visibility::Private,
                                crate::ast::Visibility::Protected => Visibility::Protected,
                            };
                            fields.push(FieldDef {
                                name: field_name.to_string(),
                                data_type: field_type,
                                visibility,
                            });
                        }
                    }
                }
            }
        }

        // Collect method IDs and operator methods
        let mut method_ids = Vec::new();
        let mut operator_methods: FxHashMap<OperatorBehavior, FunctionId> = FxHashMap::default();
        let mut explicit_properties: FxHashMap<String, crate::semantic::types::PropertyAccessors> = FxHashMap::default();

        // First, process methods from mixins (they take precedence over inherited methods,
        // but NOT over methods explicitly defined in this class)
        for mixin_name in &mixins {
            if let Some(mixin) = self.registry.lookup_mixin(mixin_name) {
                for member in mixin.members {
                    if let ClassMember::Method(method) = member {
                        // Skip if class already defines a method with this name
                        if class_method_names.contains(method.name.name) {
                            continue;
                        }
                        // Skip deleted methods
                        if method.attrs.delete {
                            continue;
                        }

                        // Register the mixin method as a method of this class
                        // This needs to be done here because mixin methods weren't registered in Pass 1
                        self.register_mixin_method(method, type_id, &mut method_ids, &mut operator_methods, &mut explicit_properties);
                    }
                }
            }
        }

        // Then process methods defined directly in the class
        for member in class.members {
            if let ClassMember::Method(method) = member {
                // Skip deleted methods - they were not registered in Pass 1
                if method.attrs.delete {
                    continue;
                }

                // Register method signature
                self.visit_function(method, Some(type_id));

                // Find the function ID for this method
                // Methods are registered with their unqualified name in the current namespace
                // We filter by object_type to only get methods belonging to THIS class
                let method_qualified_name = self.build_qualified_name(method.name.name);
                let func_ids: Vec<FunctionId> = self.registry.lookup_functions(&method_qualified_name)
                    .iter()
                    .copied()
                    .filter(|&id| self.registry.get_function(id).object_type == Some(type_id))
                    .collect();
                method_ids.extend(func_ids.iter().copied());

                // Check if this is an operator method
                // We need to resolve the return type to identify the target type
                if let Some(ret_ty_expr) = method.return_type {
                    if let Some(return_type) = self.resolve_type_expr(&ret_ty_expr.ty) {
                        if let Some(op_behavior) = self.parse_operator_method(method.name.name, &return_type) {
                            // Each operator behavior should have exactly one function
                            if let Some(&func_id) = func_ids.first() {
                                operator_methods.insert(op_behavior, func_id);
                            }
                        }
                    }
                }

                // Check if this is an explicit property accessor method
                // Pattern: get_propname() or set_propname(T) with 'property' attribute
                if method.attrs.property {
                    if let Some(prop_info) = self.parse_property_method(method.name.name) {
                        let (prop_name, is_getter) = prop_info;

                        if let Some(&func_id) = func_ids.first() {
                            let accessor = explicit_properties.entry(prop_name)
                                .or_insert_with(crate::semantic::types::PropertyAccessors::default);

                            if is_getter {
                                accessor.getter = Some(func_id);
                            } else {
                                accessor.setter = Some(func_id);
                            }
                        }
                    }
                }
            }
        }

        // Fill in params for auto-generated methods (generated in Pass 1 with empty params)
        // Auto-generated methods are not in the AST, so visit_function() won't process them.
        // After the loop above, all AST methods have been processed by visit_function().
        // We use the auto_generated field to identify and differentiate between methods:
        // - Default constructor: auto_generated = Some(DefaultConstructor) → keep params empty
        // - Copy constructor: auto_generated = Some(CopyConstructor) → fill with const ClassName&inout
        // - OpAssign: auto_generated = Some(OpAssign) → fill with const ClassName&inout, return ClassName&
        let constructors = self.registry.find_constructors(type_id);

        for &ctor_id in &constructors {
            let func = self.registry.get_function(ctor_id);

            // Check if this is an auto-generated copy constructor
            if let Some(AutoGeneratedMethod::CopyConstructor) = func.traits.auto_generated {
                let param_type = DataType {
                    type_id,
                    is_const: true,
                    is_handle: false,
                    is_handle_to_const: false,
                    ref_modifier: RefModifier::InOut,
                };

                self.registry.update_function_params(ctor_id, vec![param_type]);
            }
            // Default constructors (auto_generated = Some(DefaultConstructor)) keep empty params
            // User-defined constructors (auto_generated = None) already have params from AST
        }

        // Fill in params and return type for auto-generated opAssign
        if let Some(op_assign_id) = self.registry.find_operator_method(type_id, OperatorBehavior::OpAssign) {
            let func = self.registry.get_function(op_assign_id);

            if let Some(AutoGeneratedMethod::OpAssign) = func.traits.auto_generated {
                // Parameter: const ClassName&inout
                let param_type = DataType {
                    type_id,
                    is_const: true,
                    is_handle: false,
                    is_handle_to_const: false,
                    ref_modifier: RefModifier::InOut,
                };

                // Return type: ClassName& (reference to self for chaining)
                let return_type = DataType {
                    type_id,
                    is_const: false,
                    is_handle: false,
                    is_handle_to_const: false,
                    ref_modifier: RefModifier::InOut,
                };

                self.registry.update_function_params(op_assign_id, vec![param_type]);
                self.registry.update_function_return_type(op_assign_id, return_type);
            }
        }

        // Process virtual properties - fill in params/return types and map to properties
        let mut properties: FxHashMap<String, crate::semantic::types::PropertyAccessors> = FxHashMap::default();

        for member in class.members {
            if let ClassMember::VirtualProperty(prop) = member {
                let prop_name = prop.name.name.to_string();
                let mut prop_accessors = crate::semantic::types::PropertyAccessors::default();

                // Resolve property type
                let prop_type = if prop.ty.ty.is_void() {
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::InvalidOperation,
                        prop.span,
                        "property cannot have void type".to_string(),
                    ));
                    continue;
                } else {
                    match self.resolve_type_expr(&prop.ty.ty) {
                        Some(dt) => dt,
                        None => {
                            self.errors.push(SemanticError::new(
                                SemanticErrorKind::UndefinedType,
                                prop.span,
                                format!("undefined type for property '{}'", prop_name),
                            ));
                            continue;
                        }
                    }
                };

                // Process each accessor (get/set)
                for accessor in prop.accessors {
                    match accessor.kind {
                        crate::ast::PropertyAccessorKind::Get => {
                            // Find the synthetic getter function
                            let getter_name = format!("get_{}", prop_name);
                            let getter_qualified = self.build_qualified_name(&getter_name);

                            if let Some(getter_ids) = self.registry.lookup_functions(&getter_qualified).first() {
                                let getter_id = *getter_ids;

                                // Update getter return type to match property type
                                self.registry.update_function_return_type(getter_id, prop_type.clone());

                                prop_accessors.getter = Some(getter_id);
                            }
                        }
                        crate::ast::PropertyAccessorKind::Set => {
                            // Find the synthetic setter function
                            let setter_name = format!("set_{}", prop_name);
                            let setter_qualified = self.build_qualified_name(&setter_name);

                            if let Some(setter_ids) = self.registry.lookup_functions(&setter_qualified).first() {
                                let setter_id = *setter_ids;

                                // Update setter parameter to receive property value
                                // Parameter: T value (or const T& for handles/objects)
                                self.registry.update_function_params(setter_id, vec![prop_type.clone()]);

                                prop_accessors.setter = Some(setter_id);
                            }
                        }
                    }
                }

                // Add to properties map
                properties.insert(prop_name, prop_accessors);
            }
        }

        // Merge explicit properties with virtual properties
        // If both exist for the same property name, virtual property takes precedence (was declared first)
        for (prop_name, explicit_accessor) in explicit_properties {
            properties.entry(prop_name).or_insert(explicit_accessor);
        }

        // Update the class definition in the registry
        self.registry.update_class_details(type_id, fields, method_ids, base_class, interfaces, operator_methods, properties);

        // Validate interface implementation (for non-abstract classes)
        self.validate_interface_implementation(class, type_id);

        // Validate method overrides ('override' keyword and 'final' checking)
        self.validate_method_overrides(class, type_id);
    }

    /// Visit an interface declaration and fill in its details
    fn visit_interface(&mut self, iface: &InterfaceDecl<'src, 'ast>) {
        let qualified_name = self.build_qualified_name(iface.name.name);

        // Look up the interface type (registered in Pass 1)
        let type_id = match self.registry.lookup_type(&qualified_name) {
            Some(id) => id,
            None => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    iface.span,
                    format!("interface '{}' was not registered in Pass 1", qualified_name),
                ));
                return;
            }
        };

        // Resolve method signatures
        let mut methods = Vec::new();
        for member in iface.members {
            if let crate::ast::decl::InterfaceMember::Method(method) = member
                && let Some(method_sig) = self.resolve_interface_method(method) {
                    methods.push(method_sig);
                }
        }

        // Update the interface definition in the registry
        self.registry.update_interface_details(type_id, methods);
    }

    /// Resolve an interface method to a MethodSignature
    fn resolve_interface_method(&mut self, method: &InterfaceMethod<'src, 'ast>) -> Option<MethodSignature> {
        // Resolve parameter types
        let params: Vec<DataType> = method
            .params
            .iter()
            .filter_map(|p| self.resolve_type_expr(&p.ty.ty))
            .collect();

        if params.len() != method.params.len() {
            return None; // Some params failed to resolve
        }

        // Resolve return type
        let return_type = self.resolve_type_expr(&method.return_type.ty)?;

        Some(MethodSignature {
            name: method.name.name.to_string(),
            params,
            return_type,
        })
    }

    /// Visit an enum declaration (already complete from Pass 1)
    fn visit_enum(&mut self, _enum_decl: &EnumDecl<'src, 'ast>) {
        // Enums are fully registered in Pass 1, nothing to do here
    }

    /// Visit a global variable declaration and resolve its type
    fn visit_global_var(&mut self, var: &GlobalVarDecl<'src, 'ast>) {
        // Resolve the variable's type
        if let Some(var_type) = self.resolve_type_expr(&var.ty) {
            // Register the global variable with its resolved type
            self.registry.register_global_var(
                var.name.name.to_string(),
                self.namespace_path.clone(),
                var_type,
            );
        }
    }

    /// Visit a namespace declaration
    fn visit_namespace(&mut self, ns: &NamespaceDecl<'src, 'ast>) {
        // Enter namespace (handle path which can be nested like A::B::C)
        for ident in ns.path {
            self.namespace_path.push(ident.name.to_string());
        }

        // Visit items inside namespace
        for item in ns.items {
            self.visit_item(item);
        }

        // Exit namespace (pop all path components we added)
        for _ in ns.path {
            self.namespace_path.pop();
        }
    }

    /// Visit a typedef declaration
    ///
    /// Typedefs create type aliases for primitive types.
    /// Example: `typedef float real;` creates `real` as an alias for `float`.
    fn visit_typedef(&mut self, typedef: &TypedefDecl<'src, 'ast>) {
        // Resolve the base type
        let base_type = match self.resolve_type_expr(&typedef.base_type) {
            Some(dt) => dt,
            None => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    typedef.span,
                    format!("cannot resolve base type for typedef '{}'", typedef.name.name),
                ));
                return;
            }
        };

        // Build the qualified name for the alias
        let alias_name = self.build_qualified_name(typedef.name.name);

        // Register the alias
        self.registry.register_type_alias(&alias_name, base_type.type_id);
    }

    /// Visit a funcdef declaration and fill in its signature
    fn visit_funcdef(&mut self, funcdef: &FuncdefDecl<'src, 'ast>) {
        let qualified_name = self.build_qualified_name(funcdef.name.name);

        // Look up the funcdef type (registered in Pass 1)
        let type_id = match self.registry.lookup_type(&qualified_name) {
            Some(id) => id,
            None => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    funcdef.span,
                    format!("funcdef '{}' was not registered in Pass 1", qualified_name),
                ));
                return;
            }
        };

        // Resolve parameter types
        let params: Vec<DataType> = funcdef
            .params
            .iter()
            .filter_map(|p| self.resolve_type_expr(&p.ty.ty))
            .collect();

        if params.len() != funcdef.params.len() {
            return; // Some params failed to resolve
        }

        // Resolve return type
        let return_type = match self.resolve_type_expr(&funcdef.return_type.ty) {
            Some(dt) => dt,
            None => return, // Error already logged
        };

        // Update the funcdef in the registry
        self.registry.update_funcdef_signature(type_id, params, return_type);
    }

    /// Resolve a TypeExpr AST node to a complete DataType
    ///
    /// This is the core type resolution method that:
    /// - Looks up the base type in the registry
    /// - Handles scoped names (Namespace::Type)
    /// - Instantiates templates recursively
    /// - Applies type modifiers (const, @)
    /// - Stores the result in type_map for later reference
    fn resolve_type_expr(&mut self, expr: &TypeExpr<'src, 'ast>) -> Option<DataType> {
        // Step 1: Resolve the base type name
        let base_type_id = self.resolve_base_type(&expr.base, expr.scope.as_ref(), expr.span)?;

        // Step 2: Handle template arguments
        let type_id = if !expr.template_args.is_empty() {
            // Resolve all template argument types recursively
            let arg_types: Vec<DataType> = expr
                .template_args
                .iter()
                .filter_map(|arg| self.resolve_type_expr(arg))
                .collect();

            // Check that all template args resolved
            if arg_types.len() != expr.template_args.len() {
                return None; // Some template args failed to resolve
            }

            // Instantiate the template
            match self.registry.instantiate_template(base_type_id, arg_types) {
                Ok(instance_id) => instance_id,
                Err(err) => {
                    self.errors.push(err);
                    return None;
                }
            }
        } else {
            base_type_id
        };

        // Step 3: Build DataType with modifiers from suffixes
        let mut data_type = DataType::simple(type_id);

        // Apply const modifier from leading const keyword
        if expr.is_const {
            data_type.is_const = true;
        }

        // Apply modifiers from suffixes
        // Note: In AngelScript, only the first @ suffix matters for handle semantics
        for suffix in expr.suffixes {
            match suffix {
                TypeSuffix::Handle { is_const } => {
                    data_type.is_handle = true;
                    data_type.is_handle_to_const = *is_const;
                    // In AngelScript, leading const + @ means handle to const
                    if expr.is_const && data_type.is_handle {
                        data_type.is_handle_to_const = true;
                        data_type.is_const = false; // Move const to handle_to_const
                    }
                    break; // Only first @ matters
                }
                TypeSuffix::Array => {
                    // Array suffix T[] creates array<T>
                    // Instantiate the array template with the current type as element type
                    match self.registry.instantiate_template(
                        crate::semantic::ARRAY_TEMPLATE,
                        vec![data_type.clone()],
                    ) {
                        Ok(array_type_id) => {
                            // Arrays are reference types, so they're handles
                            data_type = DataType::with_handle(array_type_id, false);
                        }
                        Err(err) => {
                            self.errors.push(err);
                            return None;
                        }
                    }
                }
            }
        }

        // Step 4: Store in type_map for later reference
        self.type_map.insert(expr.span, data_type.clone());

        Some(data_type)
    }

    /// Resolve the base type (without template args or modifiers)
    fn resolve_base_type(
        &mut self,
        base: &TypeBase<'src>,
        scope: Option<&crate::ast::Scope<'src, 'ast>>,
        span: Span,
    ) -> Option<TypeId> {
        match base {
            TypeBase::Primitive(prim) => Some(self.primitive_to_type_id(*prim)),

            TypeBase::Named(ident) => {
                // Build the qualified name
                let type_name = if let Some(scope) = scope {
                    // Scoped type: Namespace::Type
                    self.build_scoped_name(scope, ident.name)
                } else {
                    // Try current namespace first, then global
                    let qualified = self.build_qualified_name(ident.name);

                    // Look up in registry
                    if let Some(type_id) = self.registry.lookup_type(&qualified) {
                        return Some(type_id);
                    }

                    // If not found in current namespace, try global scope
                    if !self.namespace_path.is_empty()
                        && let Some(type_id) = self.registry.lookup_type(ident.name) {
                            return Some(type_id);
                        }

                    // Not found anywhere
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::UndefinedType,
                        span,
                        format!("undefined type '{}'", ident.name),
                    ));
                    return None;
                };

                // Look up the type
                match self.registry.lookup_type(&type_name) {
                    Some(type_id) => Some(type_id),
                    None => {
                        self.errors.push(SemanticError::new(
                            SemanticErrorKind::UndefinedType,
                            span,
                            format!("undefined type '{}'", type_name),
                        ));
                        None
                    }
                }
            }

            TypeBase::Auto => {
                // Auto type inference - not supported in type resolution yet
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    span,
                    "auto type inference not yet supported".to_string(),
                ));
                None
            }

            TypeBase::Unknown => {
                self.errors.push(SemanticError::new(
                    SemanticErrorKind::UndefinedType,
                    span,
                    "unknown type '?'".to_string(),
                ));
                None
            }
        }
    }

    /// Map a primitive type to its TypeId
    #[inline]
    fn primitive_to_type_id(&self, prim: PrimitiveType) -> TypeId {
        match prim {
            PrimitiveType::Void => self.registry.void_type,
            PrimitiveType::Bool => self.registry.bool_type,
            PrimitiveType::Int => self.registry.int32_type,
            PrimitiveType::Int8 => self.registry.int8_type,
            PrimitiveType::Int16 => self.registry.int16_type,
            PrimitiveType::Int64 => self.registry.int64_type,
            PrimitiveType::UInt => self.registry.uint32_type,
            PrimitiveType::UInt8 => self.registry.uint8_type,
            PrimitiveType::UInt16 => self.registry.uint16_type,
            PrimitiveType::UInt64 => self.registry.uint64_type,
            PrimitiveType::Float => self.registry.float_type,
            PrimitiveType::Double => self.registry.double_type,
        }
    }

    /// Build a scoped name from a Scope and identifier
    fn build_scoped_name(&self, scope: &crate::ast::Scope<'src, 'ast>, name: &str) -> String {
        let scope_parts: Vec<&str> = scope.segments.iter().map(|ident| ident.name).collect();
        format!("{}::{}", scope_parts.join("::"), name)
    }

    /// Build a qualified name from the current namespace path
    fn build_qualified_name(&self, name: &str) -> String {
        if self.namespace_path.is_empty() {
            name.to_string()
        } else {
            format!("{}::{}", self.namespace_path.join("::"), name)
        }
    }

    /// Parse an operator method name and return the OperatorBehavior if it's an operator
    ///
    /// Recognizes: opConv, opImplConv, opCast, opImplCast
    /// The return type determines the target type for the conversion
    fn parse_operator_method(
        &self,
        method_name: &str,
        return_type: &DataType,
    ) -> Option<OperatorBehavior> {
        let target_type_id = return_type.type_id;

        match method_name {
            "opConv" => Some(OperatorBehavior::OpConv(target_type_id)),
            "opImplConv" => Some(OperatorBehavior::OpImplConv(target_type_id)),
            "opCast" => Some(OperatorBehavior::OpCast(target_type_id)),
            "opImplCast" => Some(OperatorBehavior::OpImplCast(target_type_id)),
            _ => None,
        }
    }

    /// Parse an explicit property accessor method name
    /// Returns Some((property_name, is_getter)) if the name matches the pattern
    /// Pattern: get_propname() or set_propname(T)
    fn parse_property_method(&self, method_name: &str) -> Option<(String, bool)> {
        if let Some(prop_name) = method_name.strip_prefix("get_") {
            Some((prop_name.to_string(), true))
        } else if let Some(prop_name) = method_name.strip_prefix("set_") {
            Some((prop_name.to_string(), false))
        } else {
            None
        }
    }

    /// Register a method from a mixin as a method of the including class
    ///
    /// This registers a new function in the registry with the including class as the object type.
    /// The method is compiled in the context of the including class.
    fn register_mixin_method(
        &mut self,
        method: &FunctionDecl<'src, 'ast>,
        type_id: TypeId,
        method_ids: &mut Vec<FunctionId>,
        operator_methods: &mut FxHashMap<OperatorBehavior, FunctionId>,
        explicit_properties: &mut FxHashMap<String, crate::semantic::types::PropertyAccessors>,
    ) {
        // Resolve parameter types
        let params: Vec<DataType> = method
            .params
            .iter()
            .filter_map(|p| self.resolve_type_expr(&p.ty.ty))
            .collect();

        // Check if we got all params
        if params.len() != method.params.len() {
            return; // Some params failed to resolve
        }

        // Resolve return type
        let return_type = if let Some(ret_ty) = method.return_type {
            match self.resolve_type_expr(&ret_ty.ty) {
                Some(dt) => dt,
                None => return,
            }
        } else {
            DataType::simple(self.registry.void_type)
        };

        // Build function traits
        let is_constructor = method.is_constructor();
        let is_destructor = method.is_destructor;
        let is_const = method.is_const;
        let is_explicit = method.attrs.explicit;
        let is_final = method.attrs.final_;
        let is_virtual = !is_final && !is_constructor && !is_destructor;
        let is_abstract = method.body.is_none() && is_virtual;

        let traits = FunctionTraits {
            is_constructor,
            is_destructor,
            is_final,
            is_virtual,
            is_abstract,
            is_const,
            is_explicit,
            auto_generated: None,
        };

        // Capture default arguments
        let default_args: Vec<Option<&'ast Expr<'src, 'ast>>> = method
            .params
            .iter()
            .map(|p| p.default)
            .collect();

        // Get a new function ID
        let func_id = self.registry.next_function_id();

        // Create and register the function
        let func_def = crate::semantic::types::registry::FunctionDef {
            id: func_id,
            name: method.name.name.to_string(),
            namespace: self.namespace_path.clone(),
            params,
            return_type: return_type.clone(),
            object_type: Some(type_id),
            traits,
            is_native: false,
            default_args,
        };

        self.registry.register_function(func_def);
        self.registry.add_method_to_class(type_id, func_id);
        method_ids.push(func_id);

        // Check if this is an operator method
        if let Some(op_behavior) = self.parse_operator_method(method.name.name, &return_type) {
            operator_methods.insert(op_behavior, func_id);
        }

        // Check if this is an explicit property accessor method
        if method.attrs.property {
            if let Some((prop_name, is_getter)) = self.parse_property_method(method.name.name) {
                let accessor = explicit_properties.entry(prop_name)
                    .or_insert_with(crate::semantic::types::PropertyAccessors::default);

                if is_getter {
                    accessor.getter = Some(func_id);
                } else {
                    accessor.setter = Some(func_id);
                }
            }
        }
    }

    /// Validate that a non-abstract class implements all interface methods
    ///
    /// For each interface the class implements (directly or via inheritance),
    /// checks that the class provides a method with matching signature.
    fn validate_interface_implementation(
        &mut self,
        class: &ClassDecl<'src, 'ast>,
        type_id: TypeId,
    ) {
        // Skip validation for abstract classes - they can defer implementation
        if class.modifiers.abstract_ {
            return;
        }

        // Get all interfaces this class must implement
        let interfaces = self.registry.get_all_interfaces(type_id);

        for interface_id in interfaces {
            // Get interface method signatures
            let interface_methods = match self.registry.get_interface_methods(interface_id) {
                Some(methods) => methods.to_vec(), // Clone to avoid borrow issues
                None => continue,
            };

            let interface_name = self.registry.get_type(interface_id).qualified_name().to_string();

            // Check each interface method is implemented
            for method_sig in &interface_methods {
                if !self.registry.has_method_matching_interface(type_id, method_sig) {
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::MissingInterfaceMethod,
                        class.span,
                        format!(
                            "class '{}' does not implement interface method '{}' from '{}'",
                            class.name.name,
                            method_sig.name,
                            interface_name,
                        ),
                    ));
                }
            }
        }
    }

    /// Validate methods with 'override' keyword have a matching base method
    ///
    /// Also validates that methods are not overriding a final method.
    fn validate_method_overrides(
        &mut self,
        class: &ClassDecl<'src, 'ast>,
        type_id: TypeId,
    ) {
        for member in class.members {
            if let ClassMember::Method(method) = member {
                let method_name = method.name.name;

                // Check if method has 'override' attribute
                if method.attrs.override_ {
                    // Get method signature for matching
                    let params: Vec<DataType> = method
                        .params
                        .iter()
                        .filter_map(|p| self.resolve_type_expr(&p.ty.ty))
                        .collect();

                    let return_type = method
                        .return_type
                        .and_then(|rt| self.resolve_type_expr(&rt.ty))
                        .unwrap_or_else(|| DataType::simple(crate::semantic::types::VOID_TYPE));

                    // Check there's a base method to override
                    let base_method = self.registry.find_base_method_with_signature(
                        type_id,
                        method_name,
                        &params,
                        &return_type,
                    );

                    if base_method.is_none() {
                        self.errors.push(SemanticError::new(
                            SemanticErrorKind::OverrideWithoutBase,
                            method.span,
                            format!(
                                "method '{}' is marked 'override' but no matching base method exists",
                                method_name,
                            ),
                        ));
                    }
                }

                // Check if method is trying to override a final method
                // This applies whether or not 'override' keyword is used
                if let Some(final_method_id) = self.registry.is_base_method_final(type_id, method_name) {
                    let base_func = self.registry.get_function(final_method_id);
                    self.errors.push(SemanticError::new(
                        SemanticErrorKind::CannotOverrideFinal,
                        method.span,
                        format!(
                            "cannot override method '{}' which is marked 'final' in base class",
                            base_func.name,
                        ),
                    ));
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse_lenient;
    use crate::semantic::{Registrar, OperatorBehavior};
    use bumpalo::Bump;

    fn compile<'src, 'ast>(source: &'src str, arena: &'ast Bump) -> TypeCompilationData<'src, 'ast> {
        let (script, parse_errors) = parse_lenient(source, arena);
        assert!(parse_errors.is_empty(), "Parse errors: {:?}", parse_errors);

        // Pass 1: Registration
        let registration = Registrar::register(&script);
        assert!(registration.errors.is_empty(), "Registration errors: {:?}", registration.errors);

        // Pass 2a: Type compilation
        TypeCompiler::compile(&script, registration.registry)
    }

    #[test]
    fn empty_script() {
        let arena = Bump::new();
        let data = compile("", &arena);
        assert!(data.errors.is_empty());
    }

    #[test]
    fn resolve_primitive_type() {
        let arena = Bump::new();
        let data = compile("class Player { int health; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].name, "health");
            assert_eq!(fields[0].data_type.type_id, data.registry.int32_type);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_multiple_field_types() {
        let arena = Bump::new();
        let data = compile(r#"
            class Player {
                int health;
                float speed;
                bool isAlive;
                double score;
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 4);
            assert_eq!(fields[0].data_type.type_id, data.registry.int32_type);
            assert_eq!(fields[1].data_type.type_id, data.registry.float_type);
            assert_eq!(fields[2].data_type.type_id, data.registry.bool_type);
            assert_eq!(fields[3].data_type.type_id, data.registry.double_type);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_user_defined_type() {
        let arena = Bump::new();
        let data = compile(r#"
            class Position { int x; int y; }
            class Player { Position pos; }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let position_id = data.registry.lookup_type("Position").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].data_type.type_id, position_id);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_const_modifier() {
        let arena = Bump::new();
        let data = compile("class Player { const int maxHealth; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert!(fields[0].data_type.is_const);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_handle_modifier() {
        let arena = Bump::new();
        let data = compile(r#"
            class Item { }
            class Player { Item@ currentItem; }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert!(fields[0].data_type.is_handle);
            assert!(!fields[0].data_type.is_handle_to_const);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn resolve_const_handle() {
        let arena = Bump::new();
        let data = compile(r#"
            class Item { }
            class Player { const Item@ currentItem; }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert!(fields[0].data_type.is_handle);
            assert!(fields[0].data_type.is_handle_to_const);
        } else {
            panic!("Expected Class typedef");
        }
    }

    // Template tests will be added once Registry::instantiate_template is available

    #[test]
    fn operator_methods_registered() {
        let arena = Bump::new();
        let data = compile(r#"
            class Vector3 {
                float x;
                float y;
                float z;

                string opConv() const { return ""; }
                int opImplConv() const { return 0; }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let vector3_id = data.registry.lookup_type("Vector3").unwrap();
        let typedef = data.registry.get_type(vector3_id);

        if let TypeDef::Class { operator_methods, .. } = typedef {
            // Check opConv (explicit value conversion to string)
            let string_type_id = data.registry.string_type;
            let op_conv_behavior = OperatorBehavior::OpConv(string_type_id);
            assert!(operator_methods.contains_key(&op_conv_behavior),
                "opConv to string should be registered");

            // Check opImplConv (implicit value conversion to int)
            let int_type_id = data.registry.int32_type;
            let op_impl_conv_behavior = OperatorBehavior::OpImplConv(int_type_id);
            assert!(operator_methods.contains_key(&op_impl_conv_behavior),
                "opImplConv to int should be registered");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn operator_cast_methods_registered() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base { }
            class Derived : Base { }

            class Container {
                Base@ opCast() { }
                Derived@ opImplCast() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let container_id = data.registry.lookup_type("Container").unwrap();
        let base_id = data.registry.lookup_type("Base").unwrap();
        let derived_id = data.registry.lookup_type("Derived").unwrap();
        let typedef = data.registry.get_type(container_id);

        if let TypeDef::Class { operator_methods, .. } = typedef {
            // Check opCast (explicit handle cast to Base)
            let op_cast_behavior = OperatorBehavior::OpCast(base_id);
            assert!(operator_methods.contains_key(&op_cast_behavior),
                "opCast to Base@ should be registered");

            // Check opImplCast (implicit handle cast to Derived)
            let op_impl_cast_behavior = OperatorBehavior::OpImplCast(derived_id);
            assert!(operator_methods.contains_key(&op_impl_cast_behavior),
                "opImplCast to Derived@ should be registered");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn explicit_property_detection() {
        let arena = Bump::new();
        // Test that explicit property accessor methods are detected and mapped
        let data = compile(r#"
            class Player {
                private int _health;

                int get_health() const property {
                    return _health;
                }

                void set_health(int value) property {
                    _health = value;
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { properties, .. } = typedef {
            // Should have one property named "health"
            assert_eq!(properties.len(), 1, "Should have exactly one property");

            let health_prop = properties.get("health").expect("Should have 'health' property");
            assert!(health_prop.getter.is_some(), "Should have getter");
            assert!(health_prop.setter.is_some(), "Should have setter");

            // Verify getter is const
            let getter_func = data.registry.get_function(health_prop.getter.unwrap());
            assert!(getter_func.traits.is_const, "Getter must be const");
            assert_eq!(getter_func.name, "get_health");

            // Verify setter is not const
            let setter_func = data.registry.get_function(health_prop.setter.unwrap());
            assert!(!setter_func.traits.is_const, "Setter must not be const");
            assert_eq!(setter_func.name, "set_health");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn explicit_read_only_property() {
        let arena = Bump::new();
        // Test that read-only explicit properties work
        let data = compile(r#"
            class Player {
                private int _score;

                int get_score() const property {
                    return _score;
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { properties, .. } = typedef {
            let score_prop = properties.get("score").expect("Should have 'score' property");
            assert!(score_prop.getter.is_some(), "Should have getter");
            assert!(score_prop.setter.is_none(), "Should NOT have setter for read-only property");
            assert!(score_prop.is_read_only(), "Should be read-only");
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn mixed_virtual_and_explicit_properties() {
        let arena = Bump::new();
        // Test that both virtual and explicit properties can coexist
        let data = compile(r#"
            class Player {
                private int _health;
                private int _score;

                // Virtual property
                int health {
                    get const { return _health; }
                    set { _health = value; }
                }

                // Explicit property
                int get_score() const property {
                    return _score;
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { properties, .. } = typedef {
            assert_eq!(properties.len(), 2, "Should have two properties");

            // Check virtual property
            let health_prop = properties.get("health").expect("Should have 'health' property");
            assert!(health_prop.getter.is_some());
            assert!(health_prop.setter.is_some());

            // Check explicit property
            let score_prop = properties.get("score").expect("Should have 'score' property");
            assert!(score_prop.getter.is_some());
            assert!(score_prop.setter.is_none());
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn field_visibility_public() {
        let arena = Bump::new();
        let data = compile("class Player { int health; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].visibility, Visibility::Public);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn field_visibility_private() {
        let arena = Bump::new();
        let data = compile("class Player { private int secret; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].visibility, Visibility::Private);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn field_visibility_protected() {
        let arena = Bump::new();
        let data = compile("class Player { protected int inherited; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let player_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(player_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].visibility, Visibility::Protected);
        } else {
            panic!("Expected Class typedef");
        }
    }

    #[test]
    fn typedef_creates_alias() {
        let arena = Bump::new();
        let data = compile("typedef float real;", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        // 'real' should resolve to the same type as 'float'
        let real_id = data.registry.lookup_type("real");
        let float_id = data.registry.lookup_type("float");

        assert!(real_id.is_some(), "typedef 'real' should be registered");
        assert_eq!(real_id, float_id, "typedef should point to same type as float");
    }

    #[test]
    fn typedef_in_namespace() {
        let arena = Bump::new();
        let data = compile("namespace Math { typedef double number; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let number_id = data.registry.lookup_type("Math::number");
        let double_id = data.registry.lookup_type("double");

        assert!(number_id.is_some(), "typedef 'Math::number' should be registered");
        assert_eq!(number_id, double_id, "typedef should point to same type as double");
    }

    #[test]
    fn array_suffix_instantiates_template() {
        let arena = Bump::new();
        let data = compile("class Container { int[] numbers; }", &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);

        let container_id = data.registry.lookup_type("Container").unwrap();
        let typedef = data.registry.get_type(container_id);

        if let TypeDef::Class { fields, .. } = typedef {
            assert_eq!(fields.len(), 1);
            // The field type should be array<int>@ (handle)
            assert!(fields[0].data_type.is_handle);

            // Check that it's an array template instance
            let field_type = data.registry.get_type(fields[0].data_type.type_id);
            assert!(field_type.is_template_instance(), "Field type should be array<int>");
        } else {
            panic!("Expected Class typedef");
        }
    }

    // ========================================================================
    // Interface Implementation Validation Tests
    // ========================================================================

    #[test]
    fn interface_implementation_complete() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
                int getWidth();
            }

            class Widget : IDrawable {
                void draw() { }
                int getWidth() { return 0; }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Errors: {:?}", data.errors);
    }

    #[test]
    fn interface_method_missing_error() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
                int getWidth();
            }

            class Widget : IDrawable {
                void draw() { }
                // Missing: int getWidth()
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing interface method");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("getWidth"));
    }

    #[test]
    fn interface_method_wrong_signature_error() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                int getWidth();
            }

            class Widget : IDrawable {
                // Wrong return type (void instead of int)
                void getWidth() { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for wrong signature");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
    }

    #[test]
    fn abstract_class_partial_interface_ok() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
                int getWidth();
            }

            abstract class AbstractWidget : IDrawable {
                // Only implements one method - OK because abstract
                void draw() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Abstract class should not need to implement all interface methods. Errors: {:?}", data.errors);
    }

    #[test]
    fn interface_method_inherited_from_base() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            class BaseWidget : IDrawable {
                void draw() { }
            }

            class DerivedWidget : BaseWidget {
                // Inherits draw() from BaseWidget, so interface is satisfied
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Interface method inherited from base should satisfy requirement. Errors: {:?}", data.errors);
    }

    #[test]
    fn multiple_interfaces_all_implemented() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            interface IClickable {
                void onClick();
            }

            class Button : IDrawable, IClickable {
                void draw() { }
                void onClick() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "All interface methods implemented. Errors: {:?}", data.errors);
    }

    #[test]
    fn multiple_interfaces_one_missing() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            interface IClickable {
                void onClick();
            }

            class Button : IDrawable, IClickable {
                void draw() { }
                // Missing: onClick()
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing onClick");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("onClick"));
    }

    #[test]
    fn abstract_class_defers_interface_to_concrete_subclass() {
        // Abstract class implements interface but defers implementation to concrete subclass
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            abstract class Widget : IDrawable {
                // Abstract class doesn't implement draw() - OK, defers to subclass
            }

            class Button : Widget {
                void draw() { }  // Concrete class provides implementation
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Abstract class can defer interface to concrete subclass. Errors: {:?}", data.errors);
    }

    #[test]
    fn concrete_class_missing_inherited_interface_method() {
        // Concrete class inherits from abstract class that implements interface,
        // but doesn't provide the implementation
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            abstract class Widget : IDrawable {
                // Abstract class doesn't implement draw()
            }

            class Button : Widget {
                // Concrete class ALSO doesn't implement draw() - ERROR!
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing interface method");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("draw"));
    }

    #[test]
    fn abstract_class_chain_with_interface() {
        // Chain of abstract classes, only the final concrete one needs to implement
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            abstract class Widget : IDrawable { }

            abstract class ClickableWidget : Widget { }

            class Button : ClickableWidget {
                void draw() { }  // Finally implemented here
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Chain of abstract classes, implementation at end. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_class_chain_multiple_interfaces_all_implemented() {
        // Abstract class chain with multiple interfaces at different levels
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            interface IClickable {
                void onClick();
            }

            interface IFocusable {
                void onFocus();
            }

            abstract class Widget : IDrawable { }

            abstract class InteractiveWidget : Widget, IClickable, IFocusable { }

            class Button : InteractiveWidget {
                void draw() { }      // From IDrawable (on Widget)
                void onClick() { }   // From IClickable (on InteractiveWidget)
                void onFocus() { }   // From IFocusable (on InteractiveWidget)
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Concrete class implements all inherited interfaces. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_class_chain_multiple_interfaces_one_missing() {
        // Abstract class chain with multiple interfaces, but concrete class misses one
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            interface IClickable {
                void onClick();
            }

            interface IFocusable {
                void onFocus();
            }

            abstract class Widget : IDrawable { }

            abstract class InteractiveWidget : Widget, IClickable, IFocusable { }

            class Button : InteractiveWidget {
                void draw() { }      // From IDrawable (on Widget)
                void onClick() { }   // From IClickable (on InteractiveWidget)
                // Missing: onFocus() from IFocusable
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing onFocus");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("onFocus"));
    }

    #[test]
    fn abstract_class_partial_implementation() {
        // Abstract class implements some interface methods, concrete class must implement the rest
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class BaseWidget : IWidget {
                void draw() { }  // Abstract class implements draw()
                // But leaves update() for concrete class
            }

            class Button : BaseWidget {
                void update() { }  // Concrete class implements update()
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Abstract class partial implementation completed by concrete. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_class_final_method_cannot_be_overridden() {
        // Abstract class implements interface method as final, concrete subclass cannot override
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
            }

            abstract class BaseWidget : IWidget {
                void draw() final { }  // Abstract class implements draw() as final
            }

            class Button : BaseWidget {
                void draw() { }  // ERROR: Cannot override final method
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(data.errors[0].message.contains("draw"));
    }

    #[test]
    fn abstract_class_chain_final_method_in_middle() {
        // Final method in middle of abstract class chain
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class Widget : IWidget {
                void draw() final { }  // Widget implements draw() as final
                // update() left for subclasses
            }

            abstract class ClickableWidget : Widget {
                // Cannot override draw() here either - it's final from Widget
            }

            class Button : ClickableWidget {
                void update() { }   // OK: implement update()
                void draw() { }     // ERROR: Cannot override final from Widget
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method from abstract grandparent");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(data.errors[0].message.contains("draw"));
    }

    #[test]
    fn abstract_class_chain_final_method_not_overridden_ok() {
        // Final method in abstract class, concrete subclass doesn't try to override - OK
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class BaseWidget : IWidget {
                void draw() final { }  // Abstract class implements draw() as final
                // update() left for subclasses
            }

            class Button : BaseWidget {
                void update() { }  // Only implement update(), draw() is final from base
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Not overriding final method is OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_chain_with_final_method_and_intermediate_abstract() {
        // Abstract class chain: BaseWidget (final draw) -> MiddleWidget -> Button
        // Button should NOT be able to override draw() even with an intermediate abstract class
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class BaseWidget : IWidget {
                void draw() final { }  // Abstract class implements draw() as final
                // update() left for subclasses
            }

            abstract class MiddleWidget : BaseWidget {
                // MiddleWidget is abstract, doesn't implement update()
                // Cannot override draw() here either since it's final
            }

            class Button : MiddleWidget {
                void update() { }   // OK: implement update()
                void draw() { }     // ERROR: Cannot override final from BaseWidget (through MiddleWidget)
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method from grandparent abstract class");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(data.errors[0].message.contains("draw"));
    }

    #[test]
    fn abstract_chain_with_final_method_not_overridden_ok() {
        // Same chain but concrete class doesn't try to override the final method - OK
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
                void update();
            }

            abstract class BaseWidget : IWidget {
                void draw() final { }  // Abstract class implements draw() as final
            }

            abstract class MiddleWidget : BaseWidget {
                // Doesn't override draw() (it's final)
                // Doesn't implement update() (still abstract)
            }

            class Button : MiddleWidget {
                void update() { }   // Only implement update()
                // draw() is final from BaseWidget - we don't try to override
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Not overriding final method through intermediate is OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_chain_with_interface_and_multiple_intermediate_abstracts() {
        // Deep chain: IWidget -> BaseWidget -> MiddleWidget -> ConcreteButton
        // where interface method is NOT implemented until concrete class
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
            }

            abstract class BaseWidget : IWidget {
                // Doesn't implement draw() - defers to subclass
            }

            abstract class MiddleWidget : BaseWidget {
                // Still doesn't implement draw() - defers to subclass
            }

            class ConcreteButton : MiddleWidget {
                void draw() { }   // Finally implements draw() here
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Concrete class implements interface method through deep chain. Errors: {:?}", data.errors);
    }

    #[test]
    fn abstract_chain_with_interface_missing_implementation() {
        // Deep chain where no class implements the interface method - ERROR on concrete
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
            }

            abstract class BaseWidget : IWidget {
                // Doesn't implement draw()
            }

            abstract class MiddleWidget : BaseWidget {
                // Doesn't implement draw()
            }

            class ConcreteButton : MiddleWidget {
                // MISSING: draw() - ERROR!
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for missing interface method");
        assert!(data.errors[0].kind == SemanticErrorKind::MissingInterfaceMethod);
        assert!(data.errors[0].message.contains("draw"));
    }

    // ========================================================================
    // Override Keyword Validation Tests
    // ========================================================================

    #[test]
    fn override_keyword_valid() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() { }
            }

            class Derived : Base {
                void update() override { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Valid override should not produce errors. Errors: {:?}", data.errors);
    }

    #[test]
    fn override_keyword_no_base_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() { }
            }

            class Derived : Base {
                // 'override' but no matching base method (wrong name)
                void render() override { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for override without base method");
        assert!(data.errors[0].kind == SemanticErrorKind::OverrideWithoutBase);
        assert!(data.errors[0].message.contains("render"));
    }

    #[test]
    fn override_wrong_signature_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() { }
            }

            class Derived : Base {
                // 'override' but wrong parameter signature
                void update(int x) override { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for override with wrong signature");
        assert!(data.errors[0].kind == SemanticErrorKind::OverrideWithoutBase);
    }

    // ========================================================================
    // Final Method Validation Tests
    // ========================================================================

    #[test]
    fn final_method_not_overridden() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() final { }
            }

            class Derived : Base {
                // No override of final method - OK
                void render() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Not overriding final method should be OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn override_final_method_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() final { }
            }

            class Derived : Base {
                // Trying to override a final method
                void update() { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(data.errors[0].message.contains("update"));
    }

    #[test]
    fn override_final_method_with_override_keyword_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void update() final { }
            }

            class Derived : Base {
                // Trying to override a final method with override keyword
                void update() override { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding final method");
        // Should have CannotOverrideFinal error
        let has_final_error = data.errors.iter()
            .any(|e| e.kind == SemanticErrorKind::CannotOverrideFinal);
        assert!(has_final_error, "Should have CannotOverrideFinal error. Errors: {:?}", data.errors);
    }

    #[test]
    fn grandparent_final_method_error() {
        let arena = Bump::new();
        let data = compile(r#"
            class GrandParent {
                void update() final { }
            }

            class Parent : GrandParent {
                // No override here
            }

            class Child : Parent {
                // Trying to override grandparent's final method
                void update() { }
            }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for overriding grandparent's final method");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotOverrideFinal);
    }

    // ========================================================================
    // Final Class Validation Tests
    // ========================================================================

    #[test]
    fn inherit_from_non_final_class_ok() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base { }

            class Derived : Base { }
        "#, &arena);
        assert!(data.errors.is_empty(), "Inheriting from non-final class should be OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn inherit_from_final_class_error() {
        let arena = Bump::new();
        let data = compile(r#"
            final class Sealed { }

            class Derived : Sealed { }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Expected error for inheriting from final class");
        assert!(data.errors[0].kind == SemanticErrorKind::CannotInheritFromFinal);
        assert!(data.errors[0].message.contains("Sealed"));
    }

    #[test]
    fn abstract_class_can_be_inherited() {
        let arena = Bump::new();
        let data = compile(r#"
            abstract class AbstractBase { }

            class Concrete : AbstractBase { }
        "#, &arena);
        assert!(data.errors.is_empty(), "Inheriting from abstract class should be OK. Errors: {:?}", data.errors);
    }

    #[test]
    fn final_class_can_implement_interface() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IWidget {
                void draw();
            }

            final class Button : IWidget {
                void draw() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Final class implementing interface should be OK. Errors: {:?}", data.errors);
    }

    // ========================================================================
    // Mixin Tests
    // ========================================================================

    #[test]
    fn mixin_basic_method() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                void mixinMethod() { }
            }

            class MyClass : MyMixin {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Basic mixin should compile. Errors: {:?}", data.errors);

        // Verify the class got the mixin method
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let methods = data.registry.get_methods(class_id);
        let method_names: Vec<&str> = methods.iter()
            .map(|&id| data.registry.get_function(id).name.as_str())
            .collect();
        assert!(method_names.contains(&"mixinMethod"), "Class should have mixinMethod from mixin. Methods: {:?}", method_names);
    }

    #[test]
    fn mixin_basic_field() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                int mixinField;
            }

            class MyClass : MyMixin {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Mixin with field should compile. Errors: {:?}", data.errors);

        // Verify the class got the mixin field
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let fields = data.registry.get_class_fields(class_id);
        let field_names: Vec<&str> = fields.iter()
            .map(|f| f.name.as_str())
            .collect();
        assert!(field_names.contains(&"mixinField"), "Class should have mixinField from mixin. Fields: {:?}", field_names);
    }

    #[test]
    fn mixin_class_method_overrides_mixin() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                void update() { }
            }

            class MyClass : MyMixin {
                void update() { }  // Class-defined method should override mixin
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Class method should override mixin method. Errors: {:?}", data.errors);

        // Verify we only have one update method, not two
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let methods = data.registry.get_methods(class_id);
        let update_count = methods.iter()
            .filter(|&&id| data.registry.get_function(id).name == "update")
            .count();
        assert_eq!(update_count, 1, "Should have exactly one update method (class overrides mixin)");
    }

    #[test]
    fn mixin_field_not_duplicated() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                int health;
            }

            class MyClass : MyMixin {
                int health;  // Class field should override mixin field
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Class field should override mixin field. Errors: {:?}", data.errors);

        // Verify we only have one health field
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let fields = data.registry.get_class_fields(class_id);
        let health_count = fields.iter()
            .filter(|f| f.name == "health")
            .count();
        assert_eq!(health_count, 1, "Should have exactly one health field");
    }

    #[test]
    fn mixin_with_interface() {
        let arena = Bump::new();
        let data = compile(r#"
            interface IDrawable {
                void draw();
            }

            mixin class DrawableMixin : IDrawable {
                void draw() { }
            }

            class Widget : DrawableMixin {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Mixin with interface should compile. Errors: {:?}", data.errors);

        // Verify the class implements the interface
        let class_id = data.registry.lookup_type("Widget").expect("Widget not found");
        let typedef = data.registry.get_type(class_id);
        if let crate::semantic::TypeDef::Class { interfaces, .. } = typedef {
            let iface_id = data.registry.lookup_type("IDrawable").expect("IDrawable not found");
            assert!(interfaces.contains(&iface_id), "Widget should implement IDrawable from mixin");
        } else {
            panic!("Widget should be a class");
        }
    }

    #[test]
    fn multiple_mixins() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MixinA {
                void methodA() { }
            }

            mixin class MixinB {
                void methodB() { }
            }

            class MyClass : MixinA, MixinB {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Multiple mixins should compile. Errors: {:?}", data.errors);

        // Verify the class got both methods
        let class_id = data.registry.lookup_type("MyClass").expect("MyClass not found");
        let methods = data.registry.get_methods(class_id);
        let method_names: Vec<&str> = methods.iter()
            .map(|&id| data.registry.get_function(id).name.as_str())
            .collect();
        assert!(method_names.contains(&"methodA"), "Should have methodA. Methods: {:?}", method_names);
        assert!(method_names.contains(&"methodB"), "Should have methodB. Methods: {:?}", method_names);
    }

    #[test]
    fn mixin_with_base_class() {
        let arena = Bump::new();
        let data = compile(r#"
            class Base {
                void baseMethod() { }
            }

            mixin class MyMixin {
                void mixinMethod() { }
            }

            class Derived : Base, MyMixin {
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Class with base and mixin should compile. Errors: {:?}", data.errors);

        // Verify the class has the mixin method
        let class_id = data.registry.lookup_type("Derived").expect("Derived not found");
        let methods = data.registry.get_methods(class_id);
        let method_names: Vec<&str> = methods.iter()
            .map(|&id| data.registry.get_function(id).name.as_str())
            .collect();
        assert!(method_names.contains(&"mixinMethod"), "Should have mixinMethod. Methods: {:?}", method_names);
    }

    #[test]
    fn mixin_is_not_a_type() {
        let arena = Bump::new();
        let data = compile(r#"
            mixin class MyMixin {
                void method() { }
            }
        "#, &arena);
        assert!(data.errors.is_empty(), "Mixin declaration should compile. Errors: {:?}", data.errors);

        // Verify the mixin is not registered as a type
        assert!(data.registry.lookup_type("MyMixin").is_none(), "Mixin should not be registered as a type");
        // But it should be registered as a mixin
        assert!(data.registry.is_mixin("MyMixin"), "MyMixin should be registered as a mixin");
    }
}
