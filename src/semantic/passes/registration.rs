//! Pass 1: Registration - Register all global names in the Registry.
//!
//! This module implements the first pass of semantic analysis which walks the AST
//! and registers all global declarations (types, functions, variables) in the Registry.
//!
//! # What Pass 1 Does
//!
//! - Register all global types (classes, interfaces, enums, funcdefs)
//! - Register all global function names
//! - Register all global variable names
//! - Track namespace and class context dynamically
//! - Build qualified names (e.g., "Namespace::Class")
//!
//! # What Pass 1 Does NOT Do
//!
//! - Does NOT resolve type expressions (that's Pass 2a)
//! - Does NOT track local variables (that's Pass 2b)
//! - Does NOT validate inheritance (that's Pass 2a)
//! - Does NOT type check anything (that's Pass 2b)
//!
//! # Example
//!
//! ```ignore
//! use angelscript::{parse_lenient, Registrar};
//! use bumpalo::Bump;
//!
//! let arena = Bump::new();
//! let source = "class Player { void update() { } }";
//! let (script, _) = parse_lenient(source, &arena);
//!
//! let data = Registrar::register(&script);
//! assert!(data.registry.lookup_type("Player").is_some());
//! ```

use crate::semantic::const_eval::eval_const_int;
use crate::semantic::error::{SemanticError, SemanticErrorKind};
use crate::semantic::types::{
    registry::{FunctionDef, MixinDef, Registry},
    type_def::{AutoGeneratedMethod, FunctionId, FunctionTraits, TypeDef, TypeId, Visibility},
    DataType,
};
use crate::ast::decl::{
    ClassDecl, ClassMember, EnumDecl, FuncdefDecl, FunctionDecl, GlobalVarDecl, InterfaceDecl,
    Item, MixinDecl, NamespaceDecl, TypedefDecl,
};
use crate::ast::Script;
use crate::lexer::Span;
use rustc_hash::FxHashMap;

/// Output from Pass 1: Registration
#[derive(Debug)]
pub struct RegistrationData<'src, 'ast> {
    /// Registry with all global names registered (empty shells)
    pub registry: Registry<'src, 'ast>,

    /// Errors found during registration
    pub errors: Vec<SemanticError>,
}

/// Pass 1: Registration visitor
///
/// Walks the AST and registers all global declarations in the Registry.
pub struct Registrar<'src, 'ast> {
    /// The registry we're building
    registry: Registry<'src, 'ast>,

    /// Current namespace path (e.g., ["Game", "World"])
    namespace_path: Vec<String>,

    /// Current class being processed (if inside a class)
    current_class: Option<TypeId>,

    /// Track which names we've seen in the current scope (for duplicate detection)
    declared_names: FxHashMap<String, Span>,

    /// Errors found during registration
    errors: Vec<SemanticError>,

    /// Phantom markers
    _phantom: std::marker::PhantomData<(&'src str, &'ast ())>,
}

impl<'src, 'ast> Registrar<'src, 'ast> {
    /// Create a new registrar
    fn new() -> Self {
        Self {
            registry: Registry::new(),
            namespace_path: Vec::new(),
            current_class: None,
            declared_names: FxHashMap::default(),
            errors: Vec::new(),
            _phantom: std::marker::PhantomData,
        }
    }

    /// Perform Pass 1 registration on a script
    pub fn register(script: &Script<'src, 'ast>) -> RegistrationData<'src, 'ast> {
        let mut registrar = Self::new();
        registrar.visit_script(script);

        RegistrationData {
            registry: registrar.registry,
            errors: registrar.errors,
        }
    }

    /// Visit the entire script
    fn visit_script(&mut self, script: &Script<'src, 'ast>) {
        for item in script.items() {
            self.visit_item(item);
        }
    }

    /// Visit a top-level item
    fn visit_item(&mut self, item: &Item<'src, 'ast>) {
        match item {
            Item::Function(func) => self.visit_function(func, None),
            Item::Class(class) => self.visit_class(class),
            Item::Interface(iface) => self.visit_interface(iface),
            Item::Enum(enum_decl) => self.visit_enum(enum_decl),
            Item::GlobalVar(var) => self.visit_global_var(var),
            Item::Namespace(ns) => self.visit_namespace(ns),
            Item::Typedef(typedef) => self.visit_typedef(typedef),
            Item::Funcdef(funcdef) => self.visit_funcdef(funcdef),
            Item::Mixin(mixin) => self.visit_mixin(mixin),
            Item::Import(_) => {
                // Skip imports for now
            }
        }
    }

    /// Visit a function declaration
    fn visit_function(&mut self, func: &FunctionDecl<'src, 'ast>, object_type: Option<TypeId>) {
        // Note: We don't check for duplicate function names here because
        // AngelScript supports function overloading. Actual duplicate detection
        // (checking signatures) happens in Pass 2a.

        // Register function (with empty signature for now)
        let func_id = FunctionId::next();

        // Build basic function traits from AST
        // Full traits will be updated in Pass 2a
        let traits = FunctionTraits {
            is_constructor: func.is_constructor(),
            is_destructor: func.is_destructor,
            ..FunctionTraits::new()
        };

        // Convert AST visibility to semantic visibility
        let visibility = match func.visibility {
            crate::ast::Visibility::Public => Visibility::Public,
            crate::ast::Visibility::Private => Visibility::Private,
            crate::ast::Visibility::Protected => Visibility::Protected,
        };

        let func_def = FunctionDef {
            id: func_id,
            name: func.name.name.to_string(),
            namespace: self.namespace_path.clone(),
            params: Vec::new(), // Will be filled in Pass 2a
            return_type: DataType::simple(self.registry.void_type),
            object_type,
            traits,
            is_native: false,
            default_args: Vec::new(), // Will be filled in Pass 2a
            visibility,
            signature_filled: false, // Will be set to true in Pass 2a
        };

        self.registry.register_function(func_def);

        // If this is a method (has object_type), add it to the class's methods list
        if let Some(type_id) = object_type {
            self.registry.add_method_to_class(type_id, func_id);
        }
    }

    /// Visit a class declaration
    fn visit_class(&mut self, class: &ClassDecl<'src, 'ast>) {
        let qualified_name = self.build_qualified_name(class.name.name);

        // Check for duplicate declaration
        if let Some(&_prev_span) = self.declared_names.get(&qualified_name) {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::DuplicateDeclaration,
                class.span,
                format!("class '{}' is already declared", qualified_name),
            ));
            return;
        }

        // Register class type (empty shell)
        let typedef = TypeDef::Class {
            name: class.name.name.to_string(),
            qualified_name: qualified_name.clone(),
            fields: Vec::new(),  // Will be filled in Pass 2a
            methods: Vec::new(),
            base_class: None,
            interfaces: Vec::new(),
            operator_methods: rustc_hash::FxHashMap::default(),  // Will be filled in Pass 2a
            properties: rustc_hash::FxHashMap::default(),  // Will be filled in Pass 2a
            is_final: class.modifiers.final_,
            is_abstract: class.modifiers.abstract_,
        };

        let type_id = self.registry.register_type(typedef, Some(&qualified_name));
        self.declared_names.insert(qualified_name.clone(), class.span);

        // Enter class context
        let prev_class = self.current_class;
        self.current_class = Some(type_id);

        // Track which constructors and operators are explicitly declared or deleted
        let mut has_any_non_deleted_constructor = false;
        let mut has_copy_constructor = false;
        let mut default_constructor_deleted = false;
        let mut copy_constructor_deleted = false;
        let mut has_op_assign = false;
        let mut op_assign_deleted = false;

        // Visit class members (register methods)
        for member in class.members {
            match member {
                ClassMember::Method(method) => {
                    // Check if this is a constructor
                    if method.is_constructor() {
                        // Check if it's deleted
                        if method.attrs.delete {
                            // Deleted constructors are NOT registered
                            // They're just markers to prevent auto-generation
                            if method.params.is_empty() {
                                default_constructor_deleted = true;
                            } else if method.params.len() == 1 {
                                copy_constructor_deleted = true;
                            }
                            // Skip registration - deleted methods are not real functions
                            continue;
                        } else {
                            // Non-deleted constructor found
                            has_any_non_deleted_constructor = true;

                            if method.params.len() == 1 {
                                has_copy_constructor = true;
                            }
                        }
                    } else {
                        // Check if this is opAssign
                        if method.name.name == "opAssign" {
                            if method.attrs.delete {
                                op_assign_deleted = true;
                                // Skip registration - deleted methods are not real functions
                                continue;
                            } else if method.params.len() == 1 {
                                has_op_assign = true;
                            }
                        } else if method.attrs.delete {
                            // Other deleted non-constructor methods also not registered
                            continue;
                        }
                    }

                    self.visit_function(method, Some(type_id));
                }
                ClassMember::Field(_) => {
                    // Fields will be processed in Pass 2a
                }
                ClassMember::VirtualProperty(prop) => {
                    // Register getter and setter as synthetic functions
                    self.visit_virtual_property(prop, type_id);
                }
                ClassMember::Funcdef(funcdef) => {
                    // Inner funcdef in class - treat like a regular funcdef
                    self.visit_funcdef(funcdef);
                }
            }
        }

        // Auto-generate constructors and operators if needed
        // Rule 1: If NO non-deleted constructors declared AND default constructor not deleted, generate default constructor
        if !has_any_non_deleted_constructor && !default_constructor_deleted {
            self.generate_default_constructor(class.name.name, &qualified_name, type_id);
        }

        // Rule 2: If NO copy constructor declared AND copy constructor not deleted, generate copy constructor
        if !has_copy_constructor && !copy_constructor_deleted {
            self.generate_copy_constructor(class.name.name, &qualified_name, type_id);
        }

        // Rule 3: If NO opAssign with single parameter declared AND opAssign not deleted, generate opAssign
        if !has_op_assign && !op_assign_deleted {
            self.generate_op_assign(class.name.name, type_id);
        }

        // Exit class context
        self.current_class = prev_class;
    }

    /// Visit an interface declaration
    fn visit_interface(&mut self, iface: &InterfaceDecl<'src, 'ast>) {
        let qualified_name = self.build_qualified_name(iface.name.name);

        // Check for duplicate declaration
        if let Some(&_prev_span) = self.declared_names.get(&qualified_name) {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::DuplicateDeclaration,
                iface.span,
                format!("interface '{}' is already declared", qualified_name),
            ));
            return;
        }

        // Register interface type (empty shell)
        let typedef = TypeDef::Interface {
            name: iface.name.name.to_string(),
            qualified_name: qualified_name.clone(),
            methods: Vec::new(),  // Will be filled in Pass 2a
        };

        self.registry.register_type(typedef, Some(&qualified_name));
        self.declared_names.insert(qualified_name, iface.span);
    }

    /// Visit an enum declaration
    fn visit_enum(&mut self, enum_decl: &EnumDecl<'src, 'ast>) {
        let qualified_name = self.build_qualified_name(enum_decl.name.name);

        // Check for duplicate declaration
        if let Some(&_prev_span) = self.declared_names.get(&qualified_name) {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::DuplicateDeclaration,
                enum_decl.span,
                format!("enum '{}' is already declared", qualified_name),
            ));
            return;
        }

        // Register enum type with values
        // Values are assigned sequentially, with explicit values overriding
        let mut next_value: i64 = 0;
        let values = enum_decl
            .enumerators
            .iter()
            .map(|v| {
                let value = if let Some(expr) = v.value {
                    // Try to evaluate the expression as a constant
                    match eval_const_int(expr) {
                        Some(val) => {
                            next_value = val + 1;
                            val
                        }
                        None => {
                            // Can't evaluate - use default and report warning
                            // (In a complete implementation, we'd report an error)
                            let val = next_value;
                            next_value += 1;
                            val
                        }
                    }
                } else {
                    // Auto-increment from previous value
                    let val = next_value;
                    next_value += 1;
                    val
                };
                (v.name.name.to_string(), value)
            })
            .collect();

        let typedef = TypeDef::Enum {
            name: enum_decl.name.name.to_string(),
            qualified_name: qualified_name.clone(),
            values,
        };

        self.registry.register_type(typedef, Some(&qualified_name));
        self.declared_names.insert(qualified_name, enum_decl.span);
    }

    /// Visit a global variable declaration
    fn visit_global_var(&mut self, var: &GlobalVarDecl<'src, 'ast>) {
        let qualified_name = self.build_qualified_name(var.name.name);

        // Check for duplicate declaration
        if let Some(&_prev_span) = self.declared_names.get(&qualified_name) {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::DuplicateDeclaration,
                var.span,
                format!("variable '{}' is already declared", qualified_name),
            ));
            return;
        }

        // Just mark as declared (type resolution happens in Pass 2a)
        self.declared_names.insert(qualified_name, var.span);
    }

    /// Visit a namespace declaration
    fn visit_namespace(&mut self, ns: &NamespaceDecl<'src, 'ast>) {
        // Enter namespace (handle path which can be nested like A::B::C)
        for ident in ns.path {
            self.namespace_path.push(ident.name.to_string());
        }

        // Save current declared names scope
        let saved_names = std::mem::take(&mut self.declared_names);

        // Visit items inside namespace
        for item in ns.items {
            self.visit_item(item);
        }

        // Restore declared names scope
        self.declared_names = saved_names;

        // Exit namespace (pop all path components we added)
        for _ in ns.path {
            self.namespace_path.pop();
        }
    }

    /// Visit a typedef declaration
    fn visit_typedef(&mut self, _typedef: &TypedefDecl<'src, 'ast>) {
        // Typedef handling will be implemented in Pass 2a
        // For now, we just skip it
    }

    /// Visit a funcdef declaration
    fn visit_funcdef(&mut self, funcdef: &FuncdefDecl<'src, 'ast>) {
        let qualified_name = self.build_qualified_name(funcdef.name.name);

        // Check for duplicate declaration
        if let Some(&_prev_span) = self.declared_names.get(&qualified_name) {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::DuplicateDeclaration,
                funcdef.span,
                format!("funcdef '{}' is already declared", qualified_name),
            ));
            return;
        }

        // Register funcdef type (empty shell)
        let typedef = TypeDef::Funcdef {
            name: funcdef.name.name.to_string(),
            qualified_name: qualified_name.clone(),
            params: Vec::new(),  // Will be filled in Pass 2a
            return_type: DataType::simple(self.registry.void_type),
        };

        self.registry.register_type(typedef, Some(&qualified_name));
        self.declared_names.insert(qualified_name, funcdef.span);
    }

    /// Visit a mixin declaration
    fn visit_mixin(&mut self, mixin: &MixinDecl<'src, 'ast>) {
        let class = &mixin.class;
        let qualified_name = self.build_qualified_name(class.name.name);

        // Check for duplicate declaration
        if let Some(&_prev_span) = self.declared_names.get(&qualified_name) {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::DuplicateDeclaration,
                mixin.span,
                format!("mixin '{}' is already declared", qualified_name),
            ));
            return;
        }

        // Validate mixin modifiers - mixins cannot be final, shared, abstract, or external
        if class.modifiers.final_ {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::InvalidMixinModifier,
                mixin.span,
                "mixin class cannot be declared as 'final'".to_string(),
            ));
        }
        if class.modifiers.shared {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::InvalidMixinModifier,
                mixin.span,
                "mixin class cannot be declared as 'shared'".to_string(),
            ));
        }
        if class.modifiers.abstract_ {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::InvalidMixinModifier,
                mixin.span,
                "mixin class cannot be declared as 'abstract'".to_string(),
            ));
        }
        if class.modifiers.external {
            self.errors.push(SemanticError::new(
                SemanticErrorKind::InvalidMixinModifier,
                mixin.span,
                "mixin class cannot be declared as 'external'".to_string(),
            ));
        }

        // Collect interfaces from inheritance list
        // Mixins can only inherit from interfaces, not from classes
        let required_interfaces: Vec<String> = class.inheritance
            .iter()
            .map(|ident_expr| self.build_inherited_name(ident_expr))
            .collect();

        // Register the mixin (not as a type)
        let mixin_def = MixinDef {
            name: class.name.name.to_string(),
            qualified_name: qualified_name.clone(),
            namespace: self.namespace_path.clone(),
            required_interfaces,
            members: class.members,
        };

        self.registry.register_mixin(mixin_def);
        self.declared_names.insert(qualified_name, mixin.span);
    }

    /// Generate a default constructor for a class
    /// Default constructor: ClassName()
    /// Params will be filled in Pass 2a
    fn generate_default_constructor(&mut self, class_name: &str, _qualified_name: &str, type_id: TypeId) {
        let func_id = FunctionId::next();

        let func_def = FunctionDef {
            id: func_id,
            name: class_name.to_string(),
            namespace: self.namespace_path.clone(),
            params: Vec::new(),  // Empty - will be filled in Pass 2a
            return_type: DataType::simple(self.registry.void_type),
            object_type: Some(type_id),
            traits: FunctionTraits {
                is_constructor: true,
                is_destructor: false,
                is_final: false,
                is_virtual: false,
                is_abstract: false,
                is_const: false,
                is_explicit: false,
                auto_generated: Some(AutoGeneratedMethod::DefaultConstructor),
            },
            is_native: false,
            default_args: Vec::new(),
            visibility: Visibility::Public,  // Auto-generated constructors are public
            signature_filled: true, // Auto-generated - already complete
        };

        self.registry.register_function(func_def);
        self.registry.add_method_to_class(type_id, func_id);
    }

    /// Generate a copy constructor for a class
    /// Copy constructor: ClassName(const ClassName& in)
    /// Params will be filled in Pass 2a
    fn generate_copy_constructor(&mut self, class_name: &str, _qualified_name: &str, type_id: TypeId) {
        let func_id = FunctionId::next();

        let func_def = FunctionDef {
            id: func_id,
            name: class_name.to_string(),
            namespace: self.namespace_path.clone(),
            params: Vec::new(),  // Empty - will be filled in Pass 2a with const ClassName&
            return_type: DataType::simple(self.registry.void_type),
            object_type: Some(type_id),
            traits: FunctionTraits {
                is_constructor: true,
                is_destructor: false,
                is_final: false,
                is_virtual: false,
                is_abstract: false,
                is_const: false,
                is_explicit: false,
                auto_generated: Some(AutoGeneratedMethod::CopyConstructor),
            },
            is_native: false,
            default_args: Vec::new(),
            visibility: Visibility::Public,  // Auto-generated constructors are public
            signature_filled: true, // Auto-generated - params filled in Pass 2a via update_function_params
        };

        self.registry.register_function(func_def);
        self.registry.add_method_to_class(type_id, func_id);
    }

    /// Generate an assignment operator for a class
    /// Assignment operator: ClassName& opAssign(const ClassName& in)
    /// Params will be filled in Pass 2a
    /// Generated automatically unless explicitly declared or marked as deleted
    fn generate_op_assign(&mut self, _class_name: &str, type_id: TypeId) {
        let func_id = FunctionId::next();

        let func_def = FunctionDef {
            id: func_id,
            name: "opAssign".to_string(),
            namespace: self.namespace_path.clone(),
            params: Vec::new(),  // Empty - will be filled in Pass 2a with const ClassName&
            return_type: DataType::simple(self.registry.void_type),  // Will be updated in Pass 2a to ClassName&
            object_type: Some(type_id),
            traits: FunctionTraits {
                is_constructor: false,
                is_destructor: false,
                is_final: false,
                is_virtual: false,
                is_abstract: false,
                is_const: false,
                is_explicit: false,
                auto_generated: Some(AutoGeneratedMethod::OpAssign),
            },
            is_native: false,
            default_args: Vec::new(),
            visibility: Visibility::Public,  // Auto-generated opAssign is public
            signature_filled: true, // Auto-generated - params filled in Pass 2a via update_function_params
        };

        self.registry.register_function(func_def);
        self.registry.add_method_to_class(type_id, func_id);
    }

    /// Process a virtual property declaration
    /// Creates synthetic getter and setter functions that will be mapped to the property in Pass 2a
    fn visit_virtual_property(&mut self, prop: &crate::ast::VirtualPropertyDecl, type_id: TypeId) {
        use crate::ast::PropertyAccessorKind;

        // Convert property visibility to semantic visibility
        let prop_visibility = match prop.visibility {
            crate::ast::Visibility::Public => Visibility::Public,
            crate::ast::Visibility::Private => Visibility::Private,
            crate::ast::Visibility::Protected => Visibility::Protected,
        };

        // Process each accessor (get/set)
        for accessor in prop.accessors {
            match accessor.kind {
                PropertyAccessorKind::Get => {
                    // Create synthetic getter function: T get_$propname() const
                    let func_id = FunctionId::next();

                    let func_def = FunctionDef {
                        id: func_id,
                        name: format!("get_{}", prop.name.name),
                        namespace: self.namespace_path.clone(),
                        params: Vec::new(),  // No parameters - will be filled in Pass 2a
                        return_type: DataType::simple(self.registry.void_type),  // Will be updated in Pass 2a
                        object_type: Some(type_id),
                        traits: FunctionTraits {
                            is_constructor: false,
                            is_destructor: false,
                            is_final: accessor.attrs.final_,
                            is_virtual: !accessor.attrs.final_,  // Virtual unless final
                            is_abstract: false,
                            is_const: true,  // Getters MUST be const
                            is_explicit: false,
                            auto_generated: None,
                        },
                        is_native: false,
                        default_args: Vec::new(),
                        visibility: prop_visibility,  // Inherit visibility from property
                        signature_filled: true, // Virtual property - params filled separately
                    };

                    self.registry.register_function(func_def);
                    self.registry.add_method_to_class(type_id, func_id);
                }
                PropertyAccessorKind::Set => {
                    // Create synthetic setter function: void set_$propname(T value)
                    let func_id = FunctionId::next();

                    let func_def = FunctionDef {
                        id: func_id,
                        name: format!("set_{}", prop.name.name),
                        namespace: self.namespace_path.clone(),
                        params: Vec::new(),  // Will receive value parameter - filled in Pass 2a
                        return_type: DataType::simple(self.registry.void_type),
                        object_type: Some(type_id),
                        traits: FunctionTraits {
                            is_constructor: false,
                            is_destructor: false,
                            is_final: accessor.attrs.final_,
                            is_virtual: !accessor.attrs.final_,  // Virtual unless final
                            is_abstract: false,
                            is_const: false,  // Setters are NOT const
                            is_explicit: false,
                            auto_generated: None,
                        },
                        is_native: false,
                        default_args: Vec::new(),
                        visibility: prop_visibility,  // Inherit visibility from property
                        signature_filled: true, // Virtual property - params filled separately
                    };

                    self.registry.register_function(func_def);
                    self.registry.add_method_to_class(type_id, func_id);
                }
            }
        }
    }

    fn build_qualified_name(&self, name: &str) -> String {
        Self::build_qualified_name_from_slice(&self.namespace_path, name)
    }

    /// Build a qualified name from a namespace path slice (no intermediate allocations)
    fn build_qualified_name_from_slice(namespace_path: &[String], name: &str) -> String {
        if namespace_path.is_empty() {
            name.to_string()
        } else {
            // Calculate capacity upfront
            let capacity = namespace_path.iter().map(|s| s.len()).sum::<usize>()
                + (namespace_path.len() - 1) * 2 + 2 + name.len();
            let mut result = String::with_capacity(capacity);
            for (i, part) in namespace_path.iter().enumerate() {
                if i > 0 {
                    result.push_str("::");
                }
                result.push_str(part);
            }
            result.push_str("::");
            result.push_str(name);
            result
        }
    }

    /// Build the full name from an IdentExpr used in inheritance.
    /// Handles both simple names (Base) and scoped names (Namespace::Interface).
    fn build_inherited_name(&self, ident_expr: &crate::ast::expr::IdentExpr) -> String {
        if let Some(scope) = &ident_expr.scope {
            // Has explicit scope - build directly without intermediate Vec
            let capacity = scope.segments.iter().map(|s| s.name.len()).sum::<usize>()
                + scope.segments.len() * 2 + ident_expr.ident.name.len();
            let mut result = String::with_capacity(capacity);
            for (i, segment) in scope.segments.iter().enumerate() {
                if i > 0 {
                    result.push_str("::");
                }
                result.push_str(segment.name);
            }
            result.push_str("::");
            result.push_str(ident_expr.ident.name);
            result
        } else {
            // No scope - apply current namespace
            self.build_qualified_name(ident_expr.ident.name)
        }
    }

}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse_lenient;
    use crate::semantic::types::type_def::OperatorBehavior;
    use bumpalo::Bump;

    fn register<'src, 'ast>(source: &'src str, arena: &'ast Bump) -> RegistrationData<'src, 'ast> {
        let (script, parse_errors) = parse_lenient(source, arena);
        assert!(parse_errors.is_empty(), "Parse errors: {:?}", parse_errors);
        Registrar::register(&script)
    }

    #[test]
    fn empty_script() {
        let arena = Bump::new();
        let data = register("", &arena);
        assert!(data.errors.is_empty());
        // Should still have built-in types
        assert!(data.registry.lookup_type("int").is_some());
    }

    #[test]
    fn register_simple_class() {
        let arena = Bump::new();
        let data = register("class Player { }", &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("Player").is_some());
    }

    #[test]
    fn register_class_with_fields() {
        let arena = Bump::new();
        let data = register("class Player { int health; float speed; }", &arena);
        assert!(data.errors.is_empty());
        let type_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(type_id);
        assert!(typedef.is_class());
    }

    #[test]
    fn register_class_with_methods() {
        let arena = Bump::new();
        let data = register("class Player { void update() { } void draw() { } }", &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("Player").is_some());
        // Methods are registered as functions
        assert!(!data.registry.lookup_functions("update").is_empty());
    }

    #[test]
    fn register_namespaced_class() {
        let arena = Bump::new();
        let data = register("namespace Game { class Player { } }", &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("Game::Player").is_some());
        assert!(data.registry.lookup_type("Player").is_none());
    }

    #[test]
    fn register_nested_namespace() {
        let arena = Bump::new();
        let data = register("namespace Game { namespace Entities { class Player { } } }", &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("Game::Entities::Player").is_some());
    }

    #[test]
    fn register_multiple_namespaces() {
        let arena = Bump::new();
        let data = register(r#"
            namespace A { class X { } }
            namespace B { class Y { } }
        "#, &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("A::X").is_some());
        assert!(data.registry.lookup_type("B::Y").is_some());
    }

    #[test]
    fn register_interface() {
        let arena = Bump::new();
        let data = register("interface IDrawable { void draw(); }", &arena);
        assert!(data.errors.is_empty());
        let type_id = data.registry.lookup_type("IDrawable").unwrap();
        assert!(data.registry.get_type(type_id).is_interface());
    }

    #[test]
    fn register_enum() {
        let arena = Bump::new();
        let data = register("enum Color { Red, Green, Blue }", &arena);
        assert!(data.errors.is_empty());
        let type_id = data.registry.lookup_type("Color").unwrap();
        assert!(data.registry.get_type(type_id).is_enum());
    }

    #[test]
    fn register_enum_with_values() {
        let arena = Bump::new();
        let data = register("enum Color { Red = 0, Green = 1, Blue = 2 }", &arena);
        assert!(data.errors.is_empty());
        let type_id = data.registry.lookup_type("Color").unwrap();
        let typedef = data.registry.get_type(type_id);

        if let TypeDef::Enum { values, .. } = typedef {
            assert_eq!(values.len(), 3);
            assert_eq!(values[0].0, "Red");
            assert_eq!(values[0].1, 0);
        } else {
            panic!("Expected Enum");
        }
    }

    #[test]
    fn register_funcdef() {
        let arena = Bump::new();
        let data = register("funcdef void Callback(int x);", &arena);
        assert!(data.errors.is_empty());
        let type_id = data.registry.lookup_type("Callback").unwrap();
        assert!(data.registry.get_type(type_id).is_funcdef());
    }

    #[test]
    fn register_global_function() {
        let arena = Bump::new();
        let data = register("void foo() { }", &arena);
        assert!(data.errors.is_empty());
        let functions = data.registry.lookup_functions("foo");
        assert_eq!(functions.len(), 1);
    }

    #[test]
    fn register_qualified_function() {
        let arena = Bump::new();
        let data = register("namespace Game { void update() { } }", &arena);
        assert!(data.errors.is_empty());
        let functions = data.registry.lookup_functions("Game::update");
        assert_eq!(functions.len(), 1);
    }

    #[test]
    fn register_function_overloads() {
        let arena = Bump::new();
        let data = register(r#"
            void foo(int x) { }
            void foo(float x) { }
        "#, &arena);
        assert!(data.errors.is_empty());
        let functions = data.registry.lookup_functions("foo");
        // Both registered (actual overload resolution happens in Pass 2a)
        assert!(functions.len() >= 1);
    }

    #[test]
    fn register_global_variable() {
        let arena = Bump::new();
        let data = register("int playerHealth = 100;", &arena);
        assert!(data.errors.is_empty());
        // Global variables are just marked as declared (no storage in Pass 1)
    }

    #[test]
    fn duplicate_class_error() {
        let arena = Bump::new();
        let data = register(r#"
            class Player { }
            class Player { }
        "#, &arena);
        assert!(!data.errors.is_empty());
        assert_eq!(data.errors[0].kind, SemanticErrorKind::DuplicateDeclaration);
    }

    #[test]
    fn duplicate_function_in_namespace() {
        let arena = Bump::new();
        let _data = register(r#"
            namespace Game {
                void foo() { }
                void foo() { }
            }
        "#, &arena);
        // Note: This should actually allow overloading, but for now we track duplicates
        // In a real implementation, we'd check parameter signatures
    }

    #[test]
    fn duplicate_in_different_namespaces_allowed() {
        let arena = Bump::new();
        let data = register(r#"
            namespace A { class X { } }
            namespace B { class X { } }
        "#, &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("A::X").is_some());
        assert!(data.registry.lookup_type("B::X").is_some());
    }

    #[test]
    fn namespace_isolates_names() {
        let arena = Bump::new();
        let data = register(r#"
            class Player { }
            namespace Game {
                class Player { }
            }
        "#, &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("Player").is_some());
        assert!(data.registry.lookup_type("Game::Player").is_some());
    }

    #[test]
    fn complex_nested_structure() {
        let arena = Bump::new();
        let data = register(r#"
            namespace Game {
                namespace Entities {
                    class Player {
                        void update() { }
                        void draw() { }
                    }
                    class Enemy {
                        void attack() { }
                    }
                }
                namespace UI {
                    class Button { }
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("Game::Entities::Player").is_some());
        assert!(data.registry.lookup_type("Game::Entities::Enemy").is_some());
        assert!(data.registry.lookup_type("Game::UI::Button").is_some());
    }

    #[test]
    fn mixed_declarations() {
        let arena = Bump::new();
        let data = register(r#"
            class Player { }
            interface IDrawable { void draw(); }
            enum Color { Red, Green, Blue }
            funcdef void Callback(int x);
            void main() { }
            int globalVar = 0;
        "#, &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("Player").is_some());
        assert!(data.registry.lookup_type("IDrawable").is_some());
        assert!(data.registry.lookup_type("Color").is_some());
        assert!(data.registry.lookup_type("Callback").is_some());
        assert!(!data.registry.lookup_functions("main").is_empty());
    }

    #[test]
    fn qualified_name_building() {
        let arena = Bump::new();
        let data = register(r#"
            namespace A {
                namespace B {
                    namespace C {
                        class Deep { }
                    }
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("A::B::C::Deep").is_some());
    }

    #[test]
    fn context_tracking() {
        let arena = Bump::new();
        let data = register(r#"
            namespace Outer {
                class X { }
                namespace Inner {
                    class Y { }
                }
                class Z { }
            }
        "#, &arena);
        assert!(data.errors.is_empty());
        assert!(data.registry.lookup_type("Outer::X").is_some());
        assert!(data.registry.lookup_type("Outer::Inner::Y").is_some());
        assert!(data.registry.lookup_type("Outer::Z").is_some());
    }

    #[test]
    fn builtin_types_present() {
        let arena = Bump::new();
        let data = register("", &arena);
        assert!(data.registry.lookup_type("void").is_some());
        assert!(data.registry.lookup_type("bool").is_some());
        assert!(data.registry.lookup_type("int").is_some());
        assert!(data.registry.lookup_type("uint").is_some());
        assert!(data.registry.lookup_type("float").is_some());
        assert!(data.registry.lookup_type("double").is_some());
        assert!(data.registry.lookup_type("string").is_some());
        assert!(data.registry.lookup_type("array").is_some());
        assert!(data.registry.lookup_type("dictionary").is_some());
    }

    // ============================================================================
    // Constructor Auto-Generation Tests (Task 7)
    // ============================================================================

    #[test]
    fn auto_generate_default_constructor() {
        let arena = Bump::new();
        // Class with no constructors should get default constructor
        let data = register("class Player { int health; }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Player").unwrap();
        let constructors = data.registry.find_constructors(type_id);

        // Should have 2 auto-generated constructors: default + copy
        assert_eq!(constructors.len(), 2, "Expected 2 auto-generated constructors");

        // Find default constructor (0 params)
        let default_ctor = constructors.iter().find(|&&id| {
            let func = data.registry.get_function(id);
            func.params.is_empty()
        });

        assert!(default_ctor.is_some(), "Default constructor should be auto-generated");
        let func = data.registry.get_function(*default_ctor.unwrap());
        assert!(func.traits.is_constructor);
        assert!(!func.traits.is_explicit);
    }

    #[test]
    fn auto_generate_copy_constructor() {
        let arena = Bump::new();
        // Class with no constructors should get copy constructor
        let data = register("class Player { int health; }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Player").unwrap();
        let constructors = data.registry.find_constructors(type_id);

        // Should have 2 auto-generated constructors: default + copy
        assert_eq!(constructors.len(), 2);

        // Copy constructor params will be empty until Pass 2a fills them in
        // We can't fully test copy constructor here
    }

    #[test]
    fn auto_generate_op_assign() {
        let arena = Bump::new();
        // Class with no opAssign should get auto-generated opAssign
        let data = register("class Player { int health; }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(type_id);

        // Look for opAssign in the class methods
        let methods = match typedef {
            crate::semantic::types::type_def::TypeDef::Class { methods, .. } => methods,
            _ => panic!("Expected class type"),
        };
        let op_assign = methods.iter().find(|&&id| {
            let func = data.registry.get_function(id);
            func.name == "opAssign"
        });

        assert!(op_assign.is_some(), "opAssign should be auto-generated");

        let func = data.registry.get_function(*op_assign.unwrap());
        assert_eq!(func.name, "opAssign");
        assert!(!func.traits.is_constructor);
        assert!(func.traits.auto_generated.is_some());
        // Params will be empty until Pass 2a fills them in
    }

    #[test]
    fn no_auto_generate_op_assign_if_exists() {
        let arena = Bump::new();
        // Class with explicit opAssign should NOT get auto-generated one
        let data = register(r#"
            class Player {
                int health;
                Player& opAssign(const Player&in other) {
                    health = other.health;
                    return this;
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(type_id);

        let methods = match typedef {
            crate::semantic::types::type_def::TypeDef::Class { methods, .. } => methods,
            _ => panic!("Expected class type"),
        };
        let op_assign = methods.iter().find(|&&id| {
            let func = data.registry.get_function(id);
            func.name == "opAssign"
        });

        assert!(op_assign.is_some(), "opAssign should exist");

        let func = data.registry.get_function(*op_assign.unwrap());
        assert!(func.traits.auto_generated.is_none(), "Should NOT be auto-generated");
    }

    #[test]
    fn no_auto_generate_op_assign_if_deleted() {
        let arena = Bump::new();
        // Class with deleted opAssign should NOT get auto-generated one
        let data = register("class Player { Player& opAssign(const Player&in) delete; }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(type_id);

        let methods = match typedef {
            crate::semantic::types::type_def::TypeDef::Class { methods, .. } => methods,
            _ => panic!("Expected class type"),
        };
        let op_assign = methods.iter().find(|&&id| {
            let func = data.registry.get_function(id);
            func.name == "opAssign"
        });

        assert!(op_assign.is_none(), "Deleted opAssign should prevent auto-generation");
    }

    #[test]
    fn no_auto_generate_if_constructor_exists() {
        let arena = Bump::new();
        // Class with explicit constructor should NOT get default constructor
        let data = register("class Player { Player(int h) { } }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Player").unwrap();
        let constructors = data.registry.find_constructors(type_id);

        // Should have the user-defined constructor plus auto-generated copy constructor
        // In Pass 1, we can't distinguish which is which because params are empty
        assert!(!constructors.is_empty(), "Should have constructors registered");
    }

    #[test]
    fn register_virtual_property() {
        let arena = Bump::new();
        // Test that virtual properties create getter/setter functions
        let data = register(r#"
            class Player {
                private int _health;
                int health {
                    get const { return _health; }
                    set { _health = value; }
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(type_id);

        let methods = match typedef {
            crate::semantic::types::type_def::TypeDef::Class { methods, .. } => methods,
            _ => panic!("Expected class type"),
        };

        // Should have getter and setter functions registered
        let getter = methods.iter().find(|&&id| {
            let func = data.registry.get_function(id);
            func.name == "get_health"
        });
        let setter = methods.iter().find(|&&id| {
            let func = data.registry.get_function(id);
            func.name == "set_health"
        });

        assert!(getter.is_some(), "Getter should be registered");
        assert!(setter.is_some(), "Setter should be registered");

        // Check getter is const
        let getter_func = data.registry.get_function(*getter.unwrap());
        assert!(getter_func.traits.is_const, "Getter must be const");

        // Check setter is not const
        let setter_func = data.registry.get_function(*setter.unwrap());
        assert!(!setter_func.traits.is_const, "Setter must not be const");
    }

    #[test]
    fn register_read_only_virtual_property() {
        let arena = Bump::new();
        // Test that read-only virtual properties only create getter
        let data = register(r#"
            class Player {
                private int _health;
                int health {
                    get const { return _health; }
                }
            }
        "#, &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Player").unwrap();
        let typedef = data.registry.get_type(type_id);

        let methods = match typedef {
            crate::semantic::types::type_def::TypeDef::Class { methods, .. } => methods,
            _ => panic!("Expected class type"),
        };

        // Should have getter but not setter
        let getter = methods.iter().find(|&&id| {
            let func = data.registry.get_function(id);
            func.name == "get_health"
        });
        let setter = methods.iter().find(|&&id| {
            let func = data.registry.get_function(id);
            func.name == "set_health"
        });

        assert!(getter.is_some(), "Getter should be registered");
        assert!(setter.is_none(), "Setter should NOT be registered for read-only property");
    }

    #[test]
    fn explicit_constructor_preserved() {
        let arena = Bump::new();
        // Explicit modifier should be preserved
        let data = register("class Vector3 { Vector3(int x) explicit { } }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Vector3").unwrap();
        let constructors = data.registry.find_constructors(type_id);

        // Constructor should be registered
        assert!(!constructors.is_empty(), "Constructor should be registered");
        // Note: explicit flag will be set in Pass 2a, not Pass 1
    }

    #[test]
    fn deleted_default_constructor_not_generated() {
        let arena = Bump::new();
        // Class with deleted default constructor should NOT register it
        let data = register("class NonCopyable { NonCopyable() delete; }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("NonCopyable").unwrap();
        let constructors = data.registry.find_constructors(type_id);

        // Should only have the auto-generated copy constructor
        // The deleted default constructor is NOT registered
        // Note: In Pass 1, both default and copy constructors have empty params
        // so we can only check the count
        assert_eq!(constructors.len(), 1, "Should have only auto-generated copy constructor (not the deleted default)");
    }

    #[test]
    fn deleted_copy_constructor_not_generated() {
        let arena = Bump::new();
        // Class with deleted copy constructor should NOT register it
        let data = register("class NonCopyable { NonCopyable(const NonCopyable& in) delete; }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("NonCopyable").unwrap();
        let constructors = data.registry.find_constructors(type_id);

        // Deleted constructors don't count as constructors for auto-generation purposes
        // So the default constructor SHOULD still be auto-generated
        // The deleted copy constructor is not registered
        // Therefore: 1 constructor (auto-generated default)
        assert_eq!(constructors.len(), 1, "Should have auto-generated default constructor (deleted copy doesn't prevent it)");
    }

    #[test]
    fn enum_values_auto_increment() {
        let arena = Bump::new();
        let data = register("enum Color { Red, Green, Blue }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Color").unwrap();
        let typedef = data.registry.get_type(type_id);

        if let TypeDef::Enum { values, .. } = typedef {
            assert_eq!(values.len(), 3);
            assert_eq!(values[0], ("Red".to_string(), 0));
            assert_eq!(values[1], ("Green".to_string(), 1));
            assert_eq!(values[2], ("Blue".to_string(), 2));
        } else {
            panic!("Expected Enum typedef");
        }
    }

    #[test]
    fn enum_values_explicit() {
        let arena = Bump::new();
        let data = register("enum Priority { Low = 1, Medium = 5, High = 10 }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Priority").unwrap();
        let typedef = data.registry.get_type(type_id);

        if let TypeDef::Enum { values, .. } = typedef {
            assert_eq!(values.len(), 3);
            assert_eq!(values[0], ("Low".to_string(), 1));
            assert_eq!(values[1], ("Medium".to_string(), 5));
            assert_eq!(values[2], ("High".to_string(), 10));
        } else {
            panic!("Expected Enum typedef");
        }
    }

    #[test]
    fn enum_values_mixed() {
        let arena = Bump::new();
        let data = register("enum Mixed { A, B = 10, C, D = -5, E }", &arena);
        assert!(data.errors.is_empty());

        let type_id = data.registry.lookup_type("Mixed").unwrap();
        let typedef = data.registry.get_type(type_id);

        if let TypeDef::Enum { values, .. } = typedef {
            assert_eq!(values.len(), 5);
            assert_eq!(values[0], ("A".to_string(), 0));
            assert_eq!(values[1], ("B".to_string(), 10));
            assert_eq!(values[2], ("C".to_string(), 11)); // Auto-increment from 10
            assert_eq!(values[3], ("D".to_string(), -5));
            assert_eq!(values[4], ("E".to_string(), -4)); // Auto-increment from -5
        } else {
            panic!("Expected Enum typedef");
        }
    }

    // ========================================================================
    // Mixin Registration Tests
    // ========================================================================

    #[test]
    fn mixin_registered() {
        let arena = Bump::new();
        let data = register("mixin class MyMixin { void method() { } }", &arena);
        assert!(data.errors.is_empty(), "Mixin should register without errors: {:?}", data.errors);

        // Mixin should be registered as a mixin, not as a type
        assert!(data.registry.is_mixin("MyMixin"), "MyMixin should be registered as a mixin");
        assert!(data.registry.lookup_type("MyMixin").is_none(), "Mixin should NOT be registered as a type");
    }

    #[test]
    fn mixin_final_error() {
        let arena = Bump::new();
        let data = register("final mixin class BadMixin { }", &arena);
        assert!(!data.errors.is_empty(), "Final mixin should produce an error");
        assert!(data.errors[0].kind == SemanticErrorKind::InvalidMixinModifier);
        assert!(data.errors[0].message.contains("final"));
    }

    #[test]
    fn mixin_shared_error() {
        let arena = Bump::new();
        let data = register("shared mixin class BadMixin { }", &arena);
        assert!(!data.errors.is_empty(), "Shared mixin should produce an error");
        assert!(data.errors[0].kind == SemanticErrorKind::InvalidMixinModifier);
        assert!(data.errors[0].message.contains("shared"));
    }

    #[test]
    fn mixin_abstract_error() {
        let arena = Bump::new();
        let data = register("abstract mixin class BadMixin { }", &arena);
        assert!(!data.errors.is_empty(), "Abstract mixin should produce an error");
        assert!(data.errors[0].kind == SemanticErrorKind::InvalidMixinModifier);
        assert!(data.errors[0].message.contains("abstract"));
    }

    #[test]
    fn mixin_external_error() {
        let arena = Bump::new();
        let data = register("external mixin class BadMixin { }", &arena);
        assert!(!data.errors.is_empty(), "External mixin should produce an error");
        assert!(data.errors[0].kind == SemanticErrorKind::InvalidMixinModifier);
        assert!(data.errors[0].message.contains("external"));
    }

    #[test]
    fn mixin_with_interfaces() {
        let arena = Bump::new();
        let data = register(r#"
            interface IDrawable { void draw(); }
            mixin class DrawMixin : IDrawable { void draw() { } }
        "#, &arena);
        assert!(data.errors.is_empty(), "Mixin with interface should register: {:?}", data.errors);

        let mixin = data.registry.lookup_mixin("DrawMixin").expect("DrawMixin not found");
        assert!(mixin.required_interfaces.contains(&"IDrawable".to_string()));
    }

    #[test]
    fn mixin_duplicate_error() {
        let arena = Bump::new();
        let data = register(r#"
            mixin class MyMixin { }
            mixin class MyMixin { }
        "#, &arena);
        assert!(!data.errors.is_empty(), "Duplicate mixin should produce an error");
        assert!(data.errors[0].kind == SemanticErrorKind::DuplicateDeclaration);
    }
}
