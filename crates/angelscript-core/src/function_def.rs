//! FunctionDef - function definition with complete signature.
//!
//! This module provides `FunctionDef`, which represents a complete function definition
//! including all parameters, return type, and function traits. Unlike the old 3-pass
//! architecture, functions are always registered with complete signatures.
//!
//! # Example
//!
//! ```
//! use angelscript_core::{FunctionDef, FunctionTraits, Param, DataType, TypeHash, Visibility, primitives};
//!
//! // Create a simple function: int add(int a, int b)
//! let func = FunctionDef::new(
//!     TypeHash::from_function("add", &[primitives::INT32, primitives::INT32]),
//!     "add".to_string(),
//!     vec![],
//!     vec![
//!         Param::new("a", DataType::simple(primitives::INT32)),
//!         Param::new("b", DataType::simple(primitives::INT32)),
//!     ],
//!     DataType::simple(primitives::INT32),
//!     None,
//!     FunctionTraits::default(),
//!     false,
//!     Visibility::Public,
//! );
//! assert_eq!(func.name, "add");
//! assert_eq!(func.params.len(), 2);
//! ```

use std::cell::OnceCell;
use std::fmt;

use crate::types::Visibility;
use crate::{DataType, TypeHash};

/// Function parameter with name, type, and optional default value marker.
///
/// Note: Unlike the main crate's `ScriptParam<'ast>`, this struct uses owned types
/// and does not store the default value expression. Default values are handled
/// during compilation, not stored in the definition.
#[derive(Debug, Clone, PartialEq)]
pub struct Param {
    /// Parameter name.
    pub name: String,
    /// Parameter type.
    pub data_type: DataType,
    /// Whether this parameter has a default value.
    /// The actual default expression is evaluated during compilation.
    pub has_default: bool,
    /// If true and this is a template param instantiated with a handle type,
    /// the pointed-to object is also const (not just the handle).
    ///
    /// Example: `const T&in` with T=`Obj@` becomes `const Obj@ const &in`
    /// instead of `Obj@ const &in`.
    pub if_handle_then_const: bool,
}

impl Param {
    /// Create a new parameter without a default value.
    pub fn new(name: impl Into<String>, data_type: DataType) -> Self {
        Self {
            name: name.into(),
            data_type,
            has_default: false,
            if_handle_then_const: false,
        }
    }

    /// Create a new parameter with a default value.
    pub fn with_default(name: impl Into<String>, data_type: DataType) -> Self {
        Self {
            name: name.into(),
            data_type,
            has_default: true,
            if_handle_then_const: false,
        }
    }

    /// Set the if_handle_then_const flag.
    pub fn with_if_handle_then_const(mut self, value: bool) -> Self {
        self.if_handle_then_const = value;
        self
    }
}

impl fmt::Display for Param {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} {}", self.data_type, self.name)?;
        if self.has_default {
            write!(f, " = ...")?;
        }
        Ok(())
    }
}

/// Type of auto-generated method (constructors and operators).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AutoGeneratedMethod {
    /// Auto-generated default constructor: `ClassName()`
    DefaultConstructor,
    /// Auto-generated copy constructor: `ClassName(const ClassName &in)`
    CopyConstructor,
    /// Auto-generated assignment operator: `ClassName& opAssign(const ClassName &in)`
    OpAssign,
}

/// Function traits (special function behaviors).
///
/// These flags indicate special properties of a function such as whether it's
/// a constructor, destructor, virtual method, etc.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct FunctionTraits {
    /// This is a constructor.
    pub is_constructor: bool,
    /// This is a destructor.
    pub is_destructor: bool,
    /// This function is final (cannot be overridden).
    pub is_final: bool,
    /// This function is virtual (can be overridden).
    pub is_virtual: bool,
    /// This function is abstract (must be overridden).
    pub is_abstract: bool,
    /// This function is const (doesn't modify object state).
    pub is_const: bool,
    /// This constructor is explicit (cannot be used for implicit conversions).
    pub is_explicit: bool,
    /// If this is an auto-generated method, specifies which type.
    pub auto_generated: Option<AutoGeneratedMethod>,
}

impl FunctionTraits {
    /// Create default function traits (no special behaviors).
    pub const fn new() -> Self {
        Self {
            is_constructor: false,
            is_destructor: false,
            is_final: false,
            is_virtual: false,
            is_abstract: false,
            is_const: false,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Create traits for a constructor.
    pub const fn constructor() -> Self {
        Self {
            is_constructor: true,
            is_destructor: false,
            is_final: false,
            is_virtual: false,
            is_abstract: false,
            is_const: false,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Create traits for a destructor.
    pub const fn destructor() -> Self {
        Self {
            is_constructor: false,
            is_destructor: true,
            is_final: false,
            is_virtual: false,
            is_abstract: false,
            is_const: false,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Create traits for a const method.
    pub const fn const_method() -> Self {
        Self {
            is_constructor: false,
            is_destructor: false,
            is_final: false,
            is_virtual: false,
            is_abstract: false,
            is_const: true,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Create traits for a virtual method.
    pub const fn virtual_method() -> Self {
        Self {
            is_constructor: false,
            is_destructor: false,
            is_final: false,
            is_virtual: true,
            is_abstract: false,
            is_const: false,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Set the auto-generated type.
    pub const fn with_auto_generated(mut self, auto: AutoGeneratedMethod) -> Self {
        self.auto_generated = Some(auto);
        self
    }
}

/// Function definition with complete signature.
///
/// In the 2-pass compiler architecture, functions are always registered with
/// complete signatures. There is no `signature_filled` field because functions
/// are never in an incomplete state.
#[derive(Debug, Clone)]
pub struct FunctionDef {
    /// Deterministic hash for identity - computed from qualified name and parameter types.
    pub func_hash: TypeHash,
    /// Function name (unqualified).
    pub name: String,
    /// Namespace path (e.g., `["Game", "Player"]`).
    pub namespace: Vec<String>,
    /// Parameters with types.
    pub params: Vec<Param>,
    /// Return type.
    pub return_type: DataType,
    /// Object type if this is a method.
    pub object_type: Option<TypeHash>,
    /// Function traits (virtual, const, etc.).
    pub traits: FunctionTraits,
    /// True if this is a native (FFI) function.
    pub is_native: bool,
    /// Visibility (public, private, protected) - only meaningful for methods.
    pub visibility: Visibility,
    /// Template type parameter hashes (refs to TemplateParamEntry in registry).
    pub template_params: Vec<TypeHash>,
    /// True if this function accepts variadic arguments.
    pub is_variadic: bool,
    /// Cached qualified name (computed on first access).
    cached_qualified_name: OnceCell<String>,
}

impl PartialEq for FunctionDef {
    fn eq(&self, other: &Self) -> bool {
        // Exclude cached_qualified_name from equality comparison
        self.func_hash == other.func_hash
            && self.name == other.name
            && self.namespace == other.namespace
            && self.params == other.params
            && self.return_type == other.return_type
            && self.object_type == other.object_type
            && self.traits == other.traits
            && self.is_native == other.is_native
            && self.visibility == other.visibility
            && self.template_params == other.template_params
            && self.is_variadic == other.is_variadic
    }
}

impl FunctionDef {
    /// Create a new function definition.
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        func_hash: TypeHash,
        name: String,
        namespace: Vec<String>,
        params: Vec<Param>,
        return_type: DataType,
        object_type: Option<TypeHash>,
        traits: FunctionTraits,
        is_native: bool,
        visibility: Visibility,
    ) -> Self {
        Self {
            func_hash,
            name,
            namespace,
            params,
            return_type,
            object_type,
            traits,
            is_native,
            visibility,
            template_params: Vec::new(),
            is_variadic: false,
            cached_qualified_name: OnceCell::new(),
        }
    }

    /// Create a new template function definition.
    #[allow(clippy::too_many_arguments)]
    pub fn new_template(
        func_hash: TypeHash,
        name: String,
        namespace: Vec<String>,
        params: Vec<Param>,
        return_type: DataType,
        object_type: Option<TypeHash>,
        traits: FunctionTraits,
        is_native: bool,
        visibility: Visibility,
        template_params: Vec<TypeHash>,
    ) -> Self {
        Self {
            func_hash,
            name,
            namespace,
            params,
            return_type,
            object_type,
            traits,
            is_native,
            visibility,
            template_params,
            is_variadic: false,
            cached_qualified_name: OnceCell::new(),
        }
    }

    /// Get the qualified name of this function.
    ///
    /// The result is cached on first access to avoid repeated allocations.
    ///
    /// # Example
    ///
    /// ```
    /// use angelscript_core::{FunctionDef, FunctionTraits, DataType, TypeHash, Visibility};
    ///
    /// let func = FunctionDef::new(
    ///     TypeHash::from_name("Game::Player::update"),
    ///     "update".to_string(),
    ///     vec!["Game".to_string(), "Player".to_string()],
    ///     vec![],
    ///     DataType::void(),
    ///     None,
    ///     FunctionTraits::default(),
    ///     false,
    ///     Visibility::Public,
    /// );
    /// assert_eq!(func.qualified_name(), "Game::Player::update");
    /// ```
    pub fn qualified_name(&self) -> &str {
        self.cached_qualified_name.get_or_init(|| {
            if self.namespace.is_empty() {
                self.name.clone()
            } else {
                format!("{}::{}", self.namespace.join("::"), self.name)
            }
        })
    }

    /// Check if this function is a method (belongs to an object type).
    pub fn is_method(&self) -> bool {
        self.object_type.is_some()
    }

    /// Check if this function is a constructor.
    pub fn is_constructor(&self) -> bool {
        self.traits.is_constructor
    }

    /// Check if this function is a destructor.
    pub fn is_destructor(&self) -> bool {
        self.traits.is_destructor
    }

    /// Check if this function is const.
    pub fn is_const(&self) -> bool {
        self.traits.is_const
    }

    /// Check if this function is virtual.
    pub fn is_virtual(&self) -> bool {
        self.traits.is_virtual
    }

    /// Check if this function is abstract.
    pub fn is_abstract(&self) -> bool {
        self.traits.is_abstract
    }

    /// Check if this function is final.
    pub fn is_final(&self) -> bool {
        self.traits.is_final
    }

    /// Get the number of required parameters (those without defaults).
    pub fn required_param_count(&self) -> usize {
        self.params.iter().filter(|p| !p.has_default).count()
    }

    /// Check if this is a template function.
    pub fn is_template(&self) -> bool {
        !self.template_params.is_empty()
    }

    /// Check if this function accepts variadic arguments.
    pub fn is_variadic_fn(&self) -> bool {
        self.is_variadic
    }

    /// Check if this function matches an interface method signature.
    ///
    /// Returns true if the function has matching parameter types, return type,
    /// and const-ness. The function name is assumed to already match (caller
    /// should filter by name first).
    pub fn matches_signature(&self, signature: &crate::MethodSignature) -> bool {
        // Parameter count must match
        if self.params.len() != signature.params.len() {
            return false;
        }

        // Parameter types must match
        for (param, expected) in self.params.iter().zip(signature.params.iter()) {
            if param.data_type != *expected {
                return false;
            }
        }

        // Return type must match
        if self.return_type != signature.return_type {
            return false;
        }

        // Const-ness must match (const interface method requires const implementation)
        if signature.is_const && !self.traits.is_const {
            return false;
        }

        true
    }
}

impl fmt::Display for FunctionDef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Format: [visibility] [traits] return_type name(params)
        // Example: "public virtual void update(float dt)"

        if self.visibility != Visibility::Public {
            write!(f, "{} ", self.visibility)?;
        }

        if self.traits.is_virtual {
            write!(f, "virtual ")?;
        }
        if self.traits.is_final {
            write!(f, "final ")?;
        }
        if self.traits.is_abstract {
            write!(f, "abstract ")?;
        }

        write!(f, "{} {}(", self.return_type, self.name)?;

        for (i, param) in self.params.iter().enumerate() {
            if i > 0 {
                write!(f, ", ")?;
            }
            write!(f, "{}", param)?;
        }

        write!(f, ")")?;

        if self.traits.is_const {
            write!(f, " const")?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::primitives;

    #[test]
    fn param_creation() {
        let param = Param::new("x", DataType::simple(primitives::INT32));
        assert_eq!(param.name, "x");
        assert!(!param.has_default);

        let param_default = Param::with_default("y", DataType::simple(primitives::FLOAT));
        assert_eq!(param_default.name, "y");
        assert!(param_default.has_default);
    }

    #[test]
    fn param_display() {
        let param = Param::new("x", DataType::simple(primitives::INT32));
        let s = format!("{}", param);
        assert!(s.contains("x"));

        let param_default = Param::with_default("y", DataType::simple(primitives::INT32));
        let s = format!("{}", param_default);
        assert!(s.contains("= ..."));
    }

    #[test]
    fn function_traits_default() {
        let traits = FunctionTraits::default();
        assert!(!traits.is_constructor);
        assert!(!traits.is_destructor);
        assert!(!traits.is_virtual);
        assert!(!traits.is_const);
        assert!(!traits.is_final);
        assert!(!traits.is_abstract);
        assert!(!traits.is_explicit);
        assert!(traits.auto_generated.is_none());
    }

    #[test]
    fn function_traits_constructor() {
        let traits = FunctionTraits::constructor();
        assert!(traits.is_constructor);
        assert!(!traits.is_destructor);
    }

    #[test]
    fn function_traits_destructor() {
        let traits = FunctionTraits::destructor();
        assert!(traits.is_destructor);
        assert!(!traits.is_constructor);
    }

    #[test]
    fn function_traits_const_method() {
        let traits = FunctionTraits::const_method();
        assert!(traits.is_const);
    }

    #[test]
    fn function_traits_virtual_method() {
        let traits = FunctionTraits::virtual_method();
        assert!(traits.is_virtual);
    }

    #[test]
    fn function_traits_with_auto_generated() {
        let traits = FunctionTraits::constructor()
            .with_auto_generated(AutoGeneratedMethod::DefaultConstructor);
        assert!(traits.is_constructor);
        assert_eq!(
            traits.auto_generated,
            Some(AutoGeneratedMethod::DefaultConstructor)
        );
    }

    #[test]
    fn function_def_creation() {
        let func = FunctionDef::new(
            TypeHash::from_function("add", &[primitives::INT32, primitives::INT32]),
            "add".to_string(),
            vec![],
            vec![
                Param::new("a", DataType::simple(primitives::INT32)),
                Param::new("b", DataType::simple(primitives::INT32)),
            ],
            DataType::simple(primitives::INT32),
            None,
            FunctionTraits::default(),
            false,
            Visibility::Public,
        );
        assert_eq!(func.name, "add");
        assert_eq!(func.params.len(), 2);
        assert!(!func.is_method());
    }

    #[test]
    fn function_def_qualified_name() {
        let func = FunctionDef::new(
            TypeHash::from_name("Game::update"),
            "update".to_string(),
            vec!["Game".to_string()],
            vec![],
            DataType::void(),
            None,
            FunctionTraits::default(),
            false,
            Visibility::Public,
        );
        assert_eq!(func.qualified_name(), "Game::update");
    }

    #[test]
    fn function_def_method() {
        let player_hash = TypeHash::from_name("Player");
        let func = FunctionDef::new(
            TypeHash::from_name("Player::update"),
            "update".to_string(),
            vec![],
            vec![Param::new("dt", DataType::simple(primitives::FLOAT))],
            DataType::void(),
            Some(player_hash),
            FunctionTraits::virtual_method(),
            false,
            Visibility::Public,
        );
        assert!(func.is_method());
        assert!(func.is_virtual());
        assert!(!func.is_const());
    }

    #[test]
    fn function_def_constructor() {
        let player_hash = TypeHash::from_name("Player");
        let func = FunctionDef::new(
            TypeHash::from_name("Player::Player"),
            "Player".to_string(),
            vec![],
            vec![],
            DataType::void(),
            Some(player_hash),
            FunctionTraits::constructor(),
            false,
            Visibility::Public,
        );
        assert!(func.is_constructor());
        assert!(func.is_method());
    }

    #[test]
    fn function_def_required_param_count() {
        let func = FunctionDef::new(
            TypeHash::from_name("test"),
            "test".to_string(),
            vec![],
            vec![
                Param::new("a", DataType::simple(primitives::INT32)),
                Param::new("b", DataType::simple(primitives::INT32)),
                Param::with_default("c", DataType::simple(primitives::INT32)),
            ],
            DataType::void(),
            None,
            FunctionTraits::default(),
            false,
            Visibility::Public,
        );
        assert_eq!(func.params.len(), 3);
        assert_eq!(func.required_param_count(), 2);
    }

    #[test]
    fn function_def_display() {
        let func = FunctionDef::new(
            TypeHash::from_name("update"),
            "update".to_string(),
            vec![],
            vec![Param::new("dt", DataType::simple(primitives::FLOAT))],
            DataType::void(),
            None,
            FunctionTraits::const_method(),
            false,
            Visibility::Public,
        );
        let s = format!("{}", func);
        assert!(s.contains("update"));
        assert!(s.contains("const"));
    }

    #[test]
    fn auto_generated_method_variants() {
        assert_ne!(
            AutoGeneratedMethod::DefaultConstructor,
            AutoGeneratedMethod::CopyConstructor
        );
        assert_ne!(
            AutoGeneratedMethod::CopyConstructor,
            AutoGeneratedMethod::OpAssign
        );
    }
}
