//! Metadata types generated by proc-macros.
//!
//! These types are produced by `#[derive(Any)]` and `#[angelscript::function]`
//! macros and are consumed by `Module` to build registry entries.
//!
//! # Design
//!
//! The metadata types serve as an intermediate representation between the
//! proc-macro generated code and the registry entries. This separation allows:
//!
//! 1. Macros to generate simple, self-contained metadata
//! 2. Module to combine metadata from multiple sources
//! 3. Type/function hashes to be computed at registration time
//!
//! # Example
//!
//! ```ignore
//! // Generated by #[derive(Any)]
//! impl Player {
//!     pub fn __as_type_meta() -> ClassMeta {
//!         ClassMeta {
//!             name: "Player",
//!             type_hash: TypeHash::from_name("Player"),
//!             type_kind: TypeKind::reference(),
//!             properties: vec![...],
//!             template_params: vec![],
//!         }
//!     }
//! }
//!
//! // Module collects and registers
//! module.ty::<Player>()?;
//! ```

use std::any::TypeId;

use crate::{TypeHash, TypeKind, Operator};

/// Metadata for a class type, generated by `#[derive(Any)]`.
///
/// This provides the structural information about a type that Module
/// uses to create a `ClassEntry` in the registry.
#[derive(Debug, Clone)]
pub struct ClassMeta {
    /// AngelScript type name.
    pub name: &'static str,
    /// Type hash for identity.
    pub type_hash: TypeHash,
    /// Type kind (value, reference, etc.).
    pub type_kind: TypeKind,
    /// Properties derived from fields with `#[angelscript(get, set)]`.
    pub properties: Vec<PropertyMeta>,
    /// Template parameter hashes (empty if not a template).
    pub template_params: Vec<TypeHash>,
}

/// Metadata for a property, derived from struct fields.
#[derive(Debug, Clone)]
pub struct PropertyMeta {
    /// Property name in AngelScript.
    pub name: &'static str,
    /// Whether a getter should be generated.
    pub get: bool,
    /// Whether a setter should be generated.
    pub set: bool,
    /// Rust TypeId for type resolution.
    pub rust_type: TypeId,
}

/// Metadata for a function, generated by `#[angelscript::function]`.
#[derive(Debug, Clone)]
pub struct FunctionMeta {
    /// Function name.
    pub name: &'static str,
    /// Parameter metadata.
    pub params: Vec<ParamMeta>,
    /// Return type's Rust TypeId.
    pub return_type: TypeId,
    /// True if this is an instance method (has self parameter).
    pub is_method: bool,
    /// Behavior kind (constructor, factory, operator, etc.).
    pub behavior: Option<Behavior>,
    /// True if method is const.
    pub is_const: bool,
    /// True if this is a property accessor.
    pub is_property: bool,
}

/// Metadata for a function parameter.
#[derive(Debug, Clone)]
pub struct ParamMeta {
    /// Parameter name.
    pub name: &'static str,
    /// Rust TypeId for type resolution.
    pub rust_type: TypeId,
}

/// Behavior kinds for special methods.
///
/// These correspond to AngelScript behaviors like constructors, factories,
/// destructors, and operators.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Behavior {
    // === Lifecycle ===
    /// Constructor behavior.
    Constructor,
    /// Copy constructor behavior.
    CopyConstructor,
    /// Factory behavior (for reference types).
    Factory,
    /// Destructor behavior.
    Destructor,
    /// AddRef for reference counting.
    AddRef,
    /// Release for reference counting.
    Release,

    // === List Initialization ===
    /// List constructor: `MyType t = {1, 2, 3};`
    ListConstruct,
    /// List factory: `array<int> a = {1, 2, 3};`
    ListFactory,

    // === Template ===
    /// Template validation callback.
    TemplateCallback,

    // === Operators ===
    /// Operator overload.
    Operator(Operator),

    // === GC Behaviors ===
    /// Get reference count for GC.
    GcGetRefCount,
    /// Set GC flag.
    GcSetFlag,
    /// Get GC flag.
    GcGetFlag,
    /// Enumerate references for GC.
    GcEnumRefs,
    /// Release references for GC.
    GcReleaseRefs,

    // === Weak Reference ===
    /// Get weak reference flag.
    GetWeakRefFlag,
}

impl Behavior {
    /// Check if this is a lifecycle behavior.
    pub fn is_lifecycle(&self) -> bool {
        matches!(
            self,
            Behavior::Constructor
                | Behavior::CopyConstructor
                | Behavior::Factory
                | Behavior::Destructor
                | Behavior::AddRef
                | Behavior::Release
        )
    }

    /// Check if this is a GC behavior.
    pub fn is_gc(&self) -> bool {
        matches!(
            self,
            Behavior::GcGetRefCount
                | Behavior::GcSetFlag
                | Behavior::GcGetFlag
                | Behavior::GcEnumRefs
                | Behavior::GcReleaseRefs
        )
    }

    /// Check if this is an operator.
    pub fn is_operator(&self) -> bool {
        matches!(self, Behavior::Operator(_))
    }

    /// Get the operator if this is an operator behavior.
    pub fn as_operator(&self) -> Option<Operator> {
        match self {
            Behavior::Operator(op) => Some(*op),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn class_meta_basic() {
        let meta = ClassMeta {
            name: "Player",
            type_hash: TypeHash::from_name("Player"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec![],
        };

        assert_eq!(meta.name, "Player");
        assert!(meta.type_kind.is_reference());
        assert!(meta.properties.is_empty());
        assert!(meta.template_params.is_empty());
    }

    #[test]
    fn class_meta_with_properties() {
        let meta = ClassMeta {
            name: "Entity",
            type_hash: TypeHash::from_name("Entity"),
            type_kind: TypeKind::reference(),
            properties: vec![
                PropertyMeta {
                    name: "health",
                    get: true,
                    set: true,
                    rust_type: TypeId::of::<i32>(),
                },
                PropertyMeta {
                    name: "id",
                    get: true,
                    set: false,
                    rust_type: TypeId::of::<u64>(),
                },
            ],
            template_params: vec![],
        };

        assert_eq!(meta.properties.len(), 2);
        assert!(meta.properties[0].get);
        assert!(meta.properties[0].set);
        assert!(meta.properties[1].get);
        assert!(!meta.properties[1].set);
    }

    #[test]
    fn class_meta_template() {
        let t_param = TypeHash::from_name("array::T");
        let meta = ClassMeta {
            name: "array",
            type_hash: TypeHash::from_name("array"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec![t_param],
        };

        assert_eq!(meta.template_params.len(), 1);
        assert_eq!(meta.template_params[0], t_param);
    }

    #[test]
    fn function_meta_basic() {
        let meta = FunctionMeta {
            name: "update",
            params: vec![
                ParamMeta {
                    name: "dt",
                    rust_type: TypeId::of::<f32>(),
                },
            ],
            return_type: TypeId::of::<()>(),
            is_method: true,
            behavior: None,
            is_const: false,
            is_property: false,
        };

        assert_eq!(meta.name, "update");
        assert_eq!(meta.params.len(), 1);
        assert!(meta.is_method);
        assert!(meta.behavior.is_none());
    }

    #[test]
    fn function_meta_constructor() {
        let meta = FunctionMeta {
            name: "Player",
            params: vec![],
            return_type: TypeId::of::<()>(),
            is_method: true,
            behavior: Some(Behavior::Constructor),
            is_const: false,
            is_property: false,
        };

        assert!(meta.behavior.as_ref().unwrap().is_lifecycle());
    }

    #[test]
    fn function_meta_operator() {
        let meta = FunctionMeta {
            name: "add",
            params: vec![],
            return_type: TypeId::of::<()>(),
            is_method: true,
            behavior: Some(Behavior::Operator(Operator::Add)),
            is_const: true,
            is_property: false,
        };

        assert!(meta.behavior.as_ref().unwrap().is_operator());
        assert_eq!(meta.behavior.as_ref().unwrap().as_operator(), Some(Operator::Add));
    }

    #[test]
    fn behavior_is_lifecycle() {
        assert!(Behavior::Constructor.is_lifecycle());
        assert!(Behavior::CopyConstructor.is_lifecycle());
        assert!(Behavior::Factory.is_lifecycle());
        assert!(Behavior::Destructor.is_lifecycle());
        assert!(Behavior::AddRef.is_lifecycle());
        assert!(Behavior::Release.is_lifecycle());
        assert!(!Behavior::GcGetRefCount.is_lifecycle());
        assert!(!Behavior::Operator(Operator::Add).is_lifecycle());
    }

    #[test]
    fn behavior_is_gc() {
        assert!(Behavior::GcGetRefCount.is_gc());
        assert!(Behavior::GcSetFlag.is_gc());
        assert!(Behavior::GcGetFlag.is_gc());
        assert!(Behavior::GcEnumRefs.is_gc());
        assert!(Behavior::GcReleaseRefs.is_gc());
        assert!(!Behavior::Constructor.is_gc());
    }
}
