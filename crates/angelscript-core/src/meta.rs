//! Metadata types generated by proc-macros.
//!
//! These types are produced by `#[derive(Any)]` and `#[angelscript::function]`
//! macros and are consumed by `Module` to build registry entries.
//!
//! # Design
//!
//! The metadata types serve as an intermediate representation between the
//! proc-macro generated code and the registry entries. This separation allows:
//!
//! 1. Macros to generate simple, self-contained metadata
//! 2. Module to combine metadata from multiple sources
//! 3. Type hashes computed via `Any` trait at compile time
//!
//! All types used in properties, parameters, and return types must implement
//! the `Any` trait. This ensures compile-time errors if a type is not registered,
//! and enables type conversion in the VM.
//!
//! # Example
//!
//! ```ignore
//! // Generated by #[derive(Any)]
//! impl Player {
//!     pub fn __as_type_meta() -> ClassMeta {
//!         ClassMeta {
//!             name: "Player",
//!             type_hash: TypeHash::from_name("Player"),
//!             type_kind: TypeKind::reference(),
//!             properties: vec![...],
//!             template_params: vec![],
//!         }
//!     }
//! }
//!
//! // Module collects and registers
//! module.ty::<Player>()?;
//! ```

use crate::{ConstantValue, TypeHash, TypeKind, Operator, RefModifier};

// =============================================================================
// Return Mode Types
// =============================================================================

/// Return mode for functions.
///
/// Specifies how a value is returned in AngelScript.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum ReturnMode {
    /// Return by value (default).
    #[default]
    Value,
    /// Return by reference (`T &` or `const T &`).
    Reference,
    /// Return by handle (`T @` or `const T @`).
    Handle,
}

/// Metadata for a function's return type.
#[derive(Debug, Clone, Default)]
pub struct ReturnMeta {
    /// Type hash of the return type. None for void or variable type (`?`).
    /// Obtained via `<T as Any>::type_hash()`.
    pub type_hash: Option<TypeHash>,
    /// How the value is returned (value, reference, handle).
    pub mode: ReturnMode,
    /// Whether the return value is const.
    pub is_const: bool,
    /// Whether this is a variable/any type (`?`) - for generic calling convention.
    pub is_variable: bool,
}

/// Metadata for a generic calling convention parameter.
///
/// Used with `#[param(...)]` to describe expected AngelScript parameters
/// when using generic calling convention.
#[derive(Debug, Clone)]
pub struct GenericParamMeta {
    /// Type hash of the parameter type.
    /// Use `primitives::VARIABLE_PARAM` for variable/any type (`?`).
    pub type_hash: TypeHash,
    /// Reference mode (none, in, out, inout).
    pub ref_mode: RefModifier,
    /// Whether this is a variadic parameter (`...`).
    pub is_variadic: bool,
    /// Default value expression as a string (e.g., "-1", "\"\"").
    pub default_value: Option<&'static str>,
    /// If true and this is a template param instantiated with a handle type,
    /// the pointed-to object is also const.
    pub if_handle_then_const: bool,
}

/// Metadata for list initialization patterns.
///
/// Used with `#[list_pattern(...)]` to describe how list initialization
/// should work for list constructors and factories.
#[derive(Debug, Clone)]
pub enum ListPatternMeta {
    /// Repeat pattern: `{T, T, ...}` - variable number of same type.
    /// Contains the type hash of the repeated element type.
    Repeat(TypeHash),
    /// Fixed pattern: `{T1, T2, T3}` - exact tuple of types.
    /// Contains type hashes in order.
    Fixed(Vec<TypeHash>),
    /// Repeat tuple pattern: `{{K, V}, {K, V}, ...}` - variable number of tuples.
    /// Contains type hashes of tuple elements.
    RepeatTuple(Vec<TypeHash>),
}

// =============================================================================
// Class and Property Metadata
// =============================================================================

/// Metadata for a class type, generated by `#[derive(Any)]`.
///
/// This provides the structural information about a type that Module
/// uses to create a `ClassEntry` in the registry.
#[derive(Debug, Clone)]
pub struct ClassMeta {
    /// AngelScript type name.
    pub name: &'static str,
    /// Type hash for identity.
    pub type_hash: TypeHash,
    /// Type kind (value, reference, etc.).
    pub type_kind: TypeKind,
    /// Properties derived from fields with `#[angelscript(get, set)]`.
    pub properties: Vec<PropertyMeta>,
    /// Template parameter names (empty if not a template).
    pub template_params: Vec<&'static str>,
    /// If this is a template specialization, the base template name.
    /// Example: For `myTemplate<float>`, this would be `Some("myTemplate")`.
    pub specialization_of: Option<&'static str>,
    /// Type arguments for template specialization.
    /// Example: For `myTemplate<float>`, this would contain the float TypeHash.
    pub specialization_args: Vec<TypeHash>,
}

/// Metadata for a property, derived from struct fields.
#[derive(Debug, Clone)]
pub struct PropertyMeta {
    /// Property name in AngelScript.
    pub name: &'static str,
    /// Whether a getter should be generated.
    pub get: bool,
    /// Whether a setter should be generated.
    pub set: bool,
    /// Type hash of the property type.
    /// Obtained via `<T as Any>::type_hash()`.
    pub type_hash: TypeHash,
}

/// Metadata for a function, generated by `#[angelscript::function]`.
#[derive(Debug, Clone)]
pub struct FunctionMeta {
    /// Rust function name.
    pub name: &'static str,
    /// Override name for AngelScript (None = use `name`).
    pub as_name: Option<&'static str>,
    /// Parameter metadata (for normal calling convention).
    pub params: Vec<ParamMeta>,
    /// Generic parameter metadata (for generic calling convention).
    pub generic_params: Vec<GenericParamMeta>,
    /// Return type metadata.
    pub return_meta: ReturnMeta,
    /// True if this is an instance method (has self parameter).
    pub is_method: bool,
    /// The type this function is associated with (for methods).
    /// None for global functions.
    pub associated_type: Option<TypeHash>,
    /// Behavior kind (constructor, factory, operator, etc.).
    pub behavior: Option<Behavior>,
    /// True if method is const.
    pub is_const: bool,
    /// True if this is a property accessor.
    pub is_property: bool,
    /// Property name for accessors (inferred from get_/set_ prefix or explicit).
    pub property_name: Option<&'static str>,
    /// True if using generic calling convention.
    pub is_generic: bool,
    /// List initialization pattern (for list constructors/factories).
    pub list_pattern: Option<ListPatternMeta>,
    /// Template parameter names for template functions (e.g., `["T", "U"]`).
    /// Empty if not a template function.
    /// Example: For `T Test<T, U>(T t, U u)`, this would be `["T", "U"]`.
    pub template_params: Vec<&'static str>,
}

/// Metadata for a function parameter.
#[derive(Debug, Clone)]
pub struct ParamMeta {
    /// Parameter name.
    pub name: &'static str,
    /// Type hash of the parameter type.
    /// Obtained via `<T as Any>::type_hash()`.
    pub type_hash: TypeHash,
    /// Default value expression as a string (e.g., "-1", "\"\"").
    pub default_value: Option<&'static str>,
    /// Template parameter name (e.g., "T", "K", "V") if this is a template param placeholder.
    /// When set, the type_hash is ignored during template instantiation and the concrete
    /// type for this template parameter is substituted instead.
    pub template_param: Option<&'static str>,
    /// If true and the template param is instantiated with a handle type,
    /// the pointed-to object is also const (not just the handle).
    ///
    /// Example: `const T&in` with T=`Obj@` becomes `const Obj@ const &in`
    /// instead of `Obj@ const &in`.
    pub if_handle_then_const: bool,
}

/// Metadata for an interface, generated by `#[angelscript::interface]`.
#[derive(Debug, Clone)]
pub struct InterfaceMeta {
    /// Interface name in AngelScript.
    pub name: &'static str,
    /// Type hash for identity.
    pub type_hash: TypeHash,
    /// Method signatures.
    pub methods: Vec<InterfaceMethodMeta>,
}

/// Metadata for an interface method.
#[derive(Debug, Clone)]
pub struct InterfaceMethodMeta {
    /// Method name.
    pub name: &'static str,
    /// Whether the method is const.
    pub is_const: bool,
    /// Parameter type hashes.
    pub param_types: Vec<TypeHash>,
    /// Return type hash.
    pub return_type: TypeHash,
}

/// Metadata for a funcdef, generated by `#[angelscript::funcdef]`.
#[derive(Debug, Clone)]
pub struct FuncdefMeta {
    /// Funcdef name in AngelScript.
    pub name: &'static str,
    /// Type hash for identity.
    pub type_hash: TypeHash,
    /// Parameter type hashes.
    pub param_types: Vec<TypeHash>,
    /// Return type hash.
    pub return_type: TypeHash,
    /// Parent type for child funcdefs (e.g., `myTemplate<T>::callback`).
    /// None for global funcdefs.
    pub parent_type: Option<TypeHash>,
}

// =============================================================================
// Global Property Metadata
// =============================================================================

/// Metadata for a global constant, generated by `#[angelscript::global]`.
///
/// This provides compile-time constant values that can be registered as
/// global properties. Only primitive types are supported (values that can
/// be stored in `ConstantValue`).
///
/// # Example
///
/// ```ignore
/// // Generated by #[angelscript::global]
/// pub fn __as_global_meta_PI() -> GlobalMeta {
///     GlobalMeta {
///         name: "PI",
///         type_name: "double",
///         type_hash: primitives::DOUBLE,
///         value_fn: || ConstantValue::Double(std::f64::consts::PI),
///     }
/// }
///
/// // Module registers it
/// module.global_meta(__as_global_meta_PI());
/// ```
#[derive(Debug, Clone)]
pub struct GlobalMeta {
    /// Name of the global property in AngelScript.
    pub name: &'static str,
    /// AngelScript type name (e.g., "int", "double", "bool").
    pub type_name: &'static str,
    /// Type hash for the property type.
    pub type_hash: TypeHash,
    /// Function that returns the constant value.
    ///
    /// This is a function pointer rather than a direct value to support
    /// computed constants (like `std::f64::consts::PI`).
    pub value_fn: fn() -> ConstantValue,
}

impl GlobalMeta {
    /// Get the constant value.
    pub fn value(&self) -> ConstantValue {
        (self.value_fn)()
    }
}

/// Behavior kinds for special methods.
///
/// These correspond to AngelScript behaviors like constructors, factories,
/// destructors, and operators.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Behavior {
    // === Lifecycle ===
    /// Constructor behavior.
    Constructor,
    /// Copy constructor behavior.
    CopyConstructor,
    /// Factory behavior (for reference types).
    Factory,
    /// Destructor behavior.
    Destructor,
    /// AddRef for reference counting.
    AddRef,
    /// Release for reference counting.
    Release,

    // === List Initialization ===
    /// List constructor: `MyType t = {1, 2, 3};`
    ListConstruct,
    /// List factory: `array<int> a = {1, 2, 3};`
    ListFactory,

    // === Template ===
    /// Template validation callback.
    TemplateCallback,

    // === Operators ===
    /// Operator overload.
    Operator(Operator),

    // === GC Behaviors ===
    /// Get reference count for GC.
    GcGetRefCount,
    /// Set GC flag.
    GcSetFlag,
    /// Get GC flag.
    GcGetFlag,
    /// Enumerate references for GC.
    GcEnumRefs,
    /// Release references for GC.
    GcReleaseRefs,

    // === Weak Reference ===
    /// Get weak reference flag.
    GetWeakRefFlag,
}

impl Behavior {
    /// Check if this is a lifecycle behavior.
    pub fn is_lifecycle(&self) -> bool {
        matches!(
            self,
            Behavior::Constructor
                | Behavior::CopyConstructor
                | Behavior::Factory
                | Behavior::Destructor
                | Behavior::AddRef
                | Behavior::Release
        )
    }

    /// Check if this is a GC behavior.
    pub fn is_gc(&self) -> bool {
        matches!(
            self,
            Behavior::GcGetRefCount
                | Behavior::GcSetFlag
                | Behavior::GcGetFlag
                | Behavior::GcEnumRefs
                | Behavior::GcReleaseRefs
        )
    }

    /// Check if this is an operator.
    pub fn is_operator(&self) -> bool {
        matches!(self, Behavior::Operator(_))
    }

    /// Get the operator if this is an operator behavior.
    pub fn as_operator(&self) -> Option<Operator> {
        match self {
            Behavior::Operator(op) => Some(*op),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{primitives, RefModifier};

    #[test]
    fn class_meta_basic() {
        let meta = ClassMeta {
            name: "Player",
            type_hash: TypeHash::from_name("Player"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec![],
            specialization_of: None,
            specialization_args: vec![],
        };

        assert_eq!(meta.name, "Player");
        assert!(meta.type_kind.is_reference());
        assert!(meta.properties.is_empty());
        assert!(meta.template_params.is_empty());
    }

    #[test]
    fn class_meta_with_properties() {
        let meta = ClassMeta {
            name: "Entity",
            type_hash: TypeHash::from_name("Entity"),
            type_kind: TypeKind::reference(),
            properties: vec![
                PropertyMeta {
                    name: "health",
                    get: true,
                    set: true,
                    type_hash: primitives::INT32,
                },
                PropertyMeta {
                    name: "id",
                    get: true,
                    set: false,
                    type_hash: primitives::UINT64,
                },
            ],
            template_params: vec![],
            specialization_of: None,
            specialization_args: vec![],
        };

        assert_eq!(meta.properties.len(), 2);
        assert!(meta.properties[0].get);
        assert!(meta.properties[0].set);
        assert!(meta.properties[1].get);
        assert!(!meta.properties[1].set);
    }

    #[test]
    fn class_meta_template() {
        let meta = ClassMeta {
            name: "array",
            type_hash: TypeHash::from_name("array"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec!["T"],
            specialization_of: None,
            specialization_args: vec![],
        };

        assert_eq!(meta.template_params.len(), 1);
        assert_eq!(meta.template_params[0], "T");
    }

    #[test]
    fn class_meta_specialization() {
        let meta = ClassMeta {
            name: "myTemplate<float>",
            type_hash: TypeHash::from_name("myTemplate<float>"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec![],
            specialization_of: Some("myTemplate"),
            specialization_args: vec![primitives::FLOAT],
        };

        assert_eq!(meta.specialization_of, Some("myTemplate"));
        assert_eq!(meta.specialization_args.len(), 1);
        assert_eq!(meta.specialization_args[0], primitives::FLOAT);
    }

    #[test]
    fn function_meta_basic() {
        let meta = FunctionMeta {
            name: "update",
            as_name: None,
            params: vec![
                ParamMeta {
                    name: "dt",
                    type_hash: primitives::FLOAT,
                    default_value: None,
                    template_param: None,
                    if_handle_then_const: false,
                },
            ],
            generic_params: vec![],
            return_meta: ReturnMeta::default(),
            is_method: true,
            associated_type: None,
            behavior: None,
            is_const: false,
            is_property: false,
            property_name: None,
            is_generic: false,
            list_pattern: None,
            template_params: vec![],
        };

        assert_eq!(meta.name, "update");
        assert_eq!(meta.params.len(), 1);
        assert!(meta.is_method);
        assert!(meta.behavior.is_none());
    }

    #[test]
    fn function_meta_constructor() {
        let meta = FunctionMeta {
            name: "Player",
            as_name: None,
            params: vec![],
            generic_params: vec![],
            return_meta: ReturnMeta::default(),
            is_method: true,
            associated_type: None,
            behavior: Some(Behavior::Constructor),
            is_const: false,
            is_property: false,
            property_name: None,
            is_generic: false,
            list_pattern: None,
            template_params: vec![],
        };

        assert!(meta.behavior.as_ref().unwrap().is_lifecycle());
    }

    #[test]
    fn function_meta_operator() {
        let meta = FunctionMeta {
            name: "add",
            as_name: None,
            params: vec![],
            generic_params: vec![],
            return_meta: ReturnMeta::default(),
            is_method: true,
            associated_type: None,
            behavior: Some(Behavior::Operator(Operator::Add)),
            is_const: true,
            is_property: false,
            property_name: None,
            is_generic: false,
            list_pattern: None,
            template_params: vec![],
        };

        assert!(meta.behavior.as_ref().unwrap().is_operator());
        assert_eq!(meta.behavior.as_ref().unwrap().as_operator(), Some(Operator::Add));
    }

    #[test]
    fn function_meta_generic() {
        let meta = FunctionMeta {
            name: "push",
            as_name: None,
            params: vec![],
            generic_params: vec![
                GenericParamMeta {
                    type_hash: primitives::VARIABLE_PARAM, // variable type
                    ref_mode: RefModifier::In,
                    is_variadic: false,
                    default_value: None,
                    if_handle_then_const: false,
                },
            ],
            return_meta: ReturnMeta::default(),
            is_method: true,
            associated_type: None,
            behavior: None,
            is_const: false,
            is_property: false,
            property_name: None,
            is_generic: true,
            list_pattern: None,
            template_params: vec![],
        };

        assert!(meta.is_generic);
        assert_eq!(meta.generic_params.len(), 1);
        assert_eq!(meta.generic_params[0].type_hash, primitives::VARIABLE_PARAM);
        assert_eq!(meta.generic_params[0].ref_mode, RefModifier::In);
    }

    #[test]
    fn return_meta_variations() {
        // Return by value
        let value_return = ReturnMeta {
            type_hash: Some(primitives::INT32),
            mode: ReturnMode::Value,
            is_const: false,
            is_variable: false,
        };
        assert_eq!(value_return.mode, ReturnMode::Value);

        // Return by const reference
        let const_ref_return = ReturnMeta {
            type_hash: Some(primitives::STRING),
            mode: ReturnMode::Reference,
            is_const: true,
            is_variable: false,
        };
        assert_eq!(const_ref_return.mode, ReturnMode::Reference);
        assert!(const_ref_return.is_const);

        // Return handle
        let handle_return = ReturnMeta {
            type_hash: Some(primitives::INT32),
            mode: ReturnMode::Handle,
            is_const: false,
            is_variable: false,
        };
        assert_eq!(handle_return.mode, ReturnMode::Handle);
    }

    #[test]
    fn list_pattern_meta() {
        // Repeat pattern
        let repeat = ListPatternMeta::Repeat(primitives::INT32);
        assert!(matches!(repeat, ListPatternMeta::Repeat(_)));

        // Fixed pattern
        let fixed = ListPatternMeta::Fixed(vec![
            primitives::FLOAT,
            primitives::FLOAT,
            primitives::FLOAT,
        ]);
        if let ListPatternMeta::Fixed(types) = fixed {
            assert_eq!(types.len(), 3);
        }

        // Repeat tuple pattern (key-value)
        let repeat_tuple = ListPatternMeta::RepeatTuple(vec![
            primitives::STRING,
            primitives::INT32,
        ]);
        if let ListPatternMeta::RepeatTuple(types) = repeat_tuple {
            assert_eq!(types.len(), 2);
        }
    }

    #[test]
    fn behavior_is_lifecycle() {
        assert!(Behavior::Constructor.is_lifecycle());
        assert!(Behavior::CopyConstructor.is_lifecycle());
        assert!(Behavior::Factory.is_lifecycle());
        assert!(Behavior::Destructor.is_lifecycle());
        assert!(Behavior::AddRef.is_lifecycle());
        assert!(Behavior::Release.is_lifecycle());
        assert!(!Behavior::GcGetRefCount.is_lifecycle());
        assert!(!Behavior::Operator(Operator::Add).is_lifecycle());
    }

    #[test]
    fn behavior_is_gc() {
        assert!(Behavior::GcGetRefCount.is_gc());
        assert!(Behavior::GcSetFlag.is_gc());
        assert!(Behavior::GcGetFlag.is_gc());
        assert!(Behavior::GcEnumRefs.is_gc());
        assert!(Behavior::GcReleaseRefs.is_gc());
        assert!(!Behavior::Constructor.is_gc());
    }

    #[test]
    fn function_meta_template_function() {
        // Template function: T Test<T, U>(T t, U u)
        let meta = FunctionMeta {
            name: "test",
            as_name: None,
            params: vec![],
            generic_params: vec![
                GenericParamMeta {
                    type_hash: primitives::VARIABLE_PARAM,
                    ref_mode: RefModifier::In,
                    is_variadic: false,
                    default_value: None,
                    if_handle_then_const: false,
                },
                GenericParamMeta {
                    type_hash: primitives::VARIABLE_PARAM,
                    ref_mode: RefModifier::In,
                    is_variadic: false,
                    default_value: None,
                    if_handle_then_const: false,
                },
            ],
            return_meta: ReturnMeta {
                type_hash: None,
                mode: ReturnMode::Value,
                is_const: false,
                is_variable: true,
            },
            is_method: false,
            associated_type: None,
            behavior: None,
            is_const: false,
            is_property: false,
            property_name: None,
            is_generic: true,
            list_pattern: None,
            template_params: vec!["T", "U"],
        };

        assert_eq!(meta.template_params.len(), 2);
        assert_eq!(meta.template_params[0], "T");
        assert_eq!(meta.template_params[1], "U");
        assert!(meta.is_generic);
        assert_eq!(meta.generic_params.len(), 2);
    }

    #[test]
    fn funcdef_meta_child_funcdef() {
        // Child funcdef: bool myTemplate<T>::callback(const T &in)
        let meta = FuncdefMeta {
            name: "callback",
            type_hash: TypeHash::from_name("callback"),
            param_types: vec![primitives::VARIABLE_PARAM],
            return_type: primitives::BOOL,
            parent_type: Some(TypeHash::from_name("myTemplate")),
        };

        assert_eq!(meta.name, "callback");
        assert!(meta.parent_type.is_some());
        assert_eq!(meta.parent_type.unwrap(), TypeHash::from_name("myTemplate"));
        assert_eq!(meta.param_types.len(), 1);
    }

    #[test]
    fn funcdef_meta_global_funcdef() {
        // Global funcdef: bool Callback(int)
        let meta = FuncdefMeta {
            name: "Callback",
            type_hash: TypeHash::from_name("Callback"),
            param_types: vec![primitives::INT32],
            return_type: primitives::BOOL,
            parent_type: None,
        };

        assert_eq!(meta.name, "Callback");
        assert!(meta.parent_type.is_none());
    }

    #[test]
    fn generic_param_meta_if_handle_then_const() {
        // Generic param with if_handle_then_const
        let param = GenericParamMeta {
            type_hash: primitives::VARIABLE_PARAM,
            ref_mode: RefModifier::In,
            is_variadic: false,
            default_value: None,
            if_handle_then_const: true,
        };

        assert!(param.if_handle_then_const);
        assert_eq!(param.type_hash, primitives::VARIABLE_PARAM);
        assert_eq!(param.ref_mode, RefModifier::In);
    }

    #[test]
    fn generic_param_meta_with_default() {
        // Generic param with default value
        let param = GenericParamMeta {
            type_hash: primitives::INT32,
            ref_mode: RefModifier::In,
            is_variadic: false,
            default_value: Some("0"),
            if_handle_then_const: false,
        };

        assert_eq!(param.default_value, Some("0"));
        assert_eq!(param.type_hash, primitives::INT32);
    }

    #[test]
    fn param_meta_with_template_param() {
        // Non-generic param with template parameter placeholder
        let param = ParamMeta {
            name: "value",
            type_hash: primitives::VARIABLE_PARAM,
            default_value: None,
            template_param: Some("T"),
            if_handle_then_const: false,
        };

        assert_eq!(param.template_param, Some("T"));
        assert_eq!(param.name, "value");
    }

    #[test]
    fn global_meta_basic() {
        use crate::ConstantValue;

        let meta = GlobalMeta {
            name: "PI",
            type_name: "double",
            type_hash: primitives::DOUBLE,
            value_fn: || ConstantValue::Double(std::f64::consts::PI),
        };

        assert_eq!(meta.name, "PI");
        assert_eq!(meta.type_name, "double");
        assert_eq!(meta.type_hash, primitives::DOUBLE);

        // Test value_fn
        let value = meta.value();
        assert!(matches!(value, ConstantValue::Double(v) if (v - std::f64::consts::PI).abs() < 0.0001));
    }

    #[test]
    fn global_meta_integer() {
        use crate::ConstantValue;

        let meta = GlobalMeta {
            name: "MAX_PLAYERS",
            type_name: "int",
            type_hash: primitives::INT32,
            value_fn: || ConstantValue::Int32(64),
        };

        assert_eq!(meta.name, "MAX_PLAYERS");
        assert_eq!(meta.value(), ConstantValue::Int32(64));
    }
}
