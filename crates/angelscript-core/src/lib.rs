// Allow approximate PI values in tests - we use 3.14 as a convenient test float value
#![cfg_attr(test, allow(clippy::approx_constant))]

//! AngelScript Core Types
//!
//! This crate provides the core type definitions shared between the FFI
//! and compiler crates in the AngelScript implementation.
//!
//! ## Core Types
//!
//! - [`TypeHash`]: Deterministic 64-bit hash for type identity
//! - [`DataType`]: Complete type with modifiers (const, handle, reference)
//! - [`FunctionDef`]: Function definitions with complete signatures
//! - [`TypeBehaviors`]: Lifecycle behaviors for types
//! - [`Span`]: Source location tracking for error reporting
//!
//! ## Registry Entry Types
//!
//! - [`TypeEntry`]: Unified enum for type storage in registry
//! - [`ClassEntry`], [`EnumEntry`], [`InterfaceEntry`], [`FuncdefEntry`]: Type entries
//! - [`FunctionEntry`]: Function storage with implementation
//! - [`TypeSource`], [`FunctionSource`]: Origin tracking (FFI vs script)
//!
//! ## Operators
//!
//! - [`Operator`]: Operator enum for proc-macro attributes
//!
//! ## Traits
//!
//! - [`Any`]: Trait for types registrable with AngelScript
//!
//! ## Error Types
//!
//! - [`AngelScriptError`]: Unified error type for all phases
//! - [`LexError`]: Lexer/tokenization errors
//! - [`ParseError`]: Parser errors with [`ParseErrorKind`]
//! - [`ParseErrors`]: Collection of parse errors
//! - [`RegistrationError`]: Type/function registration errors
//! - [`CompilationError`]: Semantic analysis and compilation errors
//! - [`RuntimeError`]: Execution/runtime errors
//!
//! # FFI Contract for VM Implementers
//!
//! When implementing a VM that executes AngelScript bytecode, these types define
//! the contract between the compiler and runtime:
//!
//! ## Type Identity
//!
//! - [`TypeHash`] is the unique identifier for all types. It is computed deterministically
//!   from the fully-qualified type name, enabling cross-compilation consistency.
//! - FFI types must be registered with the same hash the compiler expects. Use the
//!   `#[angelscript::any]` macro to ensure consistent hash computation.
//!
//! ## Function Dispatch
//!
//! - [`FunctionEntry`] contains both the signature (`FunctionDef`) and implementation.
//! - For FFI functions, `implementation` is `FunctionImpl::Native(NativeFn)`.
//! - For script functions, `implementation` is `FunctionImpl::Script { bytecode }`.
//! - Methods are stored in `ClassEntry::methods` as a map from name to `Vec<TypeHash>`
//!   (supporting overloads).
//!
//! ## Behaviors
//!
//! Classes may have special behaviors registered in [`TypeBehaviors`]:
//! - **Constructors/Destructors**: Lifecycle management
//! - **Operators**: `opAdd`, `opSub`, `opIndex`, etc.
//! - **Conversions**: `opConv`, `opImplConv`, `opCast`, `opImplCast`
//!
//! The VM should call these behaviors at appropriate points (object construction,
//! operator expressions, implicit/explicit casts).
//!
//! ## Reference Counting
//!
//! For reference types (`TypeKind::Reference`), the VM must:
//! 1. Call `AddRef` when creating a new reference to an object
//! 2. Call `Release` when a reference goes out of scope
//! 3. Handle when `Release` returns refcount 0 (trigger destructor)

mod behaviors;
mod data_type;
mod error;
mod function_def;
mod span;
pub mod type_hash;
pub mod types;

// New types for unified type registry
mod any;
pub mod entries;
mod ids;
mod operator;

// Runtime types (native functions, VM value types, object heap)
pub mod runtime;

// Additional runtime support modules
pub mod list_buffer;
pub mod native_error;
pub mod template;

// Conversion traits for FFI
pub mod convert;

// Metadata types for proc-macros
pub mod meta;

// String factory trait
mod string_factory;

// --- Type Identity ---
pub use type_hash::{TypeHash, hash_constants, primitives};

// --- Type System ---
pub use data_type::{DataType, RefModifier};
pub use types::{MethodSignature, PrimitiveKind, ReferenceKind, TypeKind, Visibility};

// --- Registry Entries ---
pub use entries::{
    AutoGenKind, ClassEntry, ConstantValue, EnumEntry, EnumValue, FuncdefEntry, FunctionEntry,
    FunctionImpl, FunctionSource, GlobalPropertyAccessor, GlobalPropertyEntry, GlobalPropertyImpl,
    InterfaceEntry, IntoGlobalProperty, PrimitiveEntry, PropertyEntry, PropertyError,
    TemplateParamEntry, TypeEntry, TypeSource,
};

// --- Functions & Operators ---
pub use function_def::{AutoGeneratedMethod, FunctionDef, FunctionTraits, Param};
pub use operator::{ConversionEntry, Operator};

// --- Behaviors ---
pub use behaviors::{BehaviorValidationResult, ForbiddenBehavior, ListBehavior, TypeBehaviors};

// --- Runtime / FFI ---
pub use convert::{FromDynamic, IntoDynamic};
pub use list_buffer::{ListBuffer, ListPattern, TupleListBuffer};
pub use native_error::{ConversionError, NativeError};
pub use runtime::{
    CallContext, Dynamic, FuncdefHandle, NativeCallable, NativeFn, ObjectHandle, ObjectHeap,
};
pub use template::{TemplateInstanceInfo, TemplateValidation};

// --- Proc-macro Metadata ---
pub use any::Any;
pub use meta::{
    Behavior, ClassMeta, FuncdefMeta, FunctionMeta, GenericParamMeta, GlobalMeta, InterfaceMeta,
    InterfaceMethodMeta, ListPatternMeta, ParamMeta, PropertyMeta, ReturnMeta, ReturnMode,
};
pub use string_factory::StringFactory;

// --- Errors ---
pub use error::{
    AngelScriptError, CompilationError, LexError, ParseError, ParseErrorKind, ParseErrors,
    RegistrationError, RuntimeError,
};

// --- Utilities ---
pub use ids::UnitId;
pub use span::Span;
