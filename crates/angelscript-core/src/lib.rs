// Allow approximate PI values in tests - we use 3.14 as a convenient test float value
#![cfg_attr(test, allow(clippy::approx_constant))]

//! AngelScript Core Types
//!
//! This crate provides the core type definitions shared between the FFI
//! and compiler crates in the AngelScript implementation.
//!
//! ## Core Types
//!
//! - [`TypeHash`]: Deterministic 64-bit hash for type identity
//! - [`DataType`]: Complete type with modifiers (const, handle, reference)
//! - [`TypeDef`]: Type definitions (primitives, classes, interfaces, enums, funcdefs)
//! - [`FunctionDef`]: Function definitions with complete signatures
//! - [`ExprInfo`]: Expression type checking results
//! - [`TypeBehaviors`]: Lifecycle behaviors for types
//! - [`FfiExpr`]: Owned expressions for FFI default arguments
//! - [`Span`]: Source location tracking for error reporting
//!
//! ## Registry Entry Types
//!
//! - [`TypeEntry`]: Unified enum for type storage in registry
//! - [`ClassEntry`], [`EnumEntry`], [`InterfaceEntry`], [`FuncdefEntry`]: Type entries
//! - [`FunctionEntry`]: Function storage with implementation
//! - [`TypeSource`], [`FunctionSource`]: Origin tracking (FFI vs script)
//!
//! ## Operators
//!
//! - [`BinaryOp`]: Binary operators (arithmetic, logical, comparison)
//! - [`UnaryOp`]: Unary operators (negation, not, increment)
//! - [`Operator`]: Operator enum for proc-macro attributes
//!
//! ## Traits
//!
//! - [`Any`]: Trait for types registrable with AngelScript
//!
//! ## Error Types
//!
//! - [`AngelScriptError`]: Unified error type for all phases
//! - [`LexError`]: Lexer/tokenization errors
//! - [`ParseError`]: Parser errors with [`ParseErrorKind`]
//! - [`ParseErrors`]: Collection of parse errors
//! - [`RegistrationError`]: Type/function registration errors
//! - [`CompilationError`]: Semantic analysis and compilation errors
//! - [`RuntimeError`]: Execution/runtime errors
//!
//! # FFI Contract for VM Implementers
//!
//! When implementing a VM that executes AngelScript bytecode, these types define
//! the contract between the compiler and runtime:
//!
//! ## Type Identity
//!
//! - [`TypeHash`] is the unique identifier for all types. It is computed deterministically
//!   from the fully-qualified type name, enabling cross-compilation consistency.
//! - FFI types must be registered with the same hash the compiler expects. Use the
//!   `#[angelscript::any]` macro to ensure consistent hash computation.
//!
//! ## Function Dispatch
//!
//! - [`FunctionEntry`] contains both the signature (`FunctionDef`) and implementation.
//! - For FFI functions, `implementation` is `FunctionImpl::Native(NativeFn)`.
//! - For script functions, `implementation` is `FunctionImpl::Script { bytecode }`.
//! - Methods are stored in `ClassEntry::methods` as a map from name to `Vec<TypeHash>`
//!   (supporting overloads).
//!
//! ## Behaviors
//!
//! Classes may have special behaviors registered in [`TypeBehaviors`]:
//! - **Constructors/Destructors**: Lifecycle management
//! - **Operators**: `opAdd`, `opSub`, `opIndex`, etc.
//! - **Conversions**: `opConv`, `opImplConv`, `opCast`, `opImplCast`
//!
//! The VM should call these behaviors at appropriate points (object construction,
//! operator expressions, implicit/explicit casts).
//!
//! ## Reference Counting
//!
//! For reference types (`TypeKind::Reference`), the VM must:
//! 1. Call `AddRef` when creating a new reference to an object
//! 2. Call `Release` when a reference goes out of scope
//! 3. Handle when `Release` returns refcount 0 (trigger destructor)

mod behaviors;
mod data_type;
mod error;
mod function_def;
pub mod ops;
mod span;
mod type_def;
pub mod type_hash;

// New types for unified type registry
mod any;
pub mod entries;
mod ids;
mod operator;

// Native function / VM runtime types (moved from angelscript-registry)
pub mod list_buffer;
pub mod native_error;
pub mod native_fn;
pub mod template;

// Conversion traits for FFI
pub mod convert;

// Metadata types for proc-macros
pub mod meta;

// String factory trait
mod string_factory;

// TypeHash and related
pub use type_hash::{TypeHash, hash_constants, primitives};

// Operators
pub use ops::{BinaryOp, UnaryOp};

// DataType and modifiers
pub use data_type::{DataType, RefModifier};

// TypeDef and supporting types
pub use type_def::{
    FieldDef, MethodSignature, OperatorBehavior, PrimitiveKind, PropertyAccessors, ReferenceKind,
    TypeDef, TypeKind, Visibility,
};

// FunctionDef and supporting types
pub use function_def::{AutoGeneratedMethod, FunctionDef, FunctionTraits, Param};

// Type behaviors
pub use behaviors::{BehaviorValidationResult, ForbiddenBehavior, ListBehavior, TypeBehaviors};

// Source location tracking
pub use span::Span;

// Error types
pub use error::{
    AngelScriptError, CompilationError, LexError, ParseError, ParseErrorKind, ParseErrors,
    RegistrationError, RuntimeError,
};

// Native function types
pub use native_fn::{
    CallContext, Dynamic, FuncdefHandle, NativeCallable, NativeFn, ObjectHandle, ObjectHeap,
};

// Conversion traits
pub use convert::{FromDynamic, IntoDynamic};

// Native error types
pub use native_error::{ConversionError, NativeError};

// List buffer types
pub use list_buffer::{ListBuffer, ListPattern, TupleListBuffer};

// Template types
pub use template::{TemplateInstanceInfo, TemplateValidation};

// Unit ID for script compilation units
pub use ids::UnitId;

// Operator enum for proc-macro attributes
pub use operator::Operator;

// Any trait for registrable types
pub use any::Any;

// Registry entry types
pub use entries::{
    // Auto-generated function kinds
    AutoGenKind,
    ClassEntry,
    // Global property types
    ConstantValue,
    EnumEntry,
    EnumValue,
    FuncdefEntry,
    // Function entry
    FunctionEntry,
    FunctionImpl,
    FunctionSource,
    GlobalPropertyAccessor,
    GlobalPropertyEntry,
    GlobalPropertyImpl,
    InterfaceEntry,
    IntoGlobalProperty,
    // Type entries
    PrimitiveEntry,
    // Common types
    PropertyEntry,
    PropertyError,
    TemplateParamEntry,
    // Unified type entry
    TypeEntry,
    // Source tracking
    TypeSource,
};

// Proc-macro metadata types
pub use meta::{
    Behavior,
    ClassMeta,
    FuncdefMeta,
    FunctionMeta,
    GenericParamMeta,
    GlobalMeta,
    InterfaceMeta,
    InterfaceMethodMeta,
    ListPatternMeta,
    ParamMeta,
    PropertyMeta,
    ReturnMeta,
    // New types for enhanced function metadata
    ReturnMode,
};

// String factory trait
pub use string_factory::StringFactory;
