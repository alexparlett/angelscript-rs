//! Module - a container for pending type and function registrations.
//!
//! Modules collect metadata from macro-generated code and pass it to Context
//! for installation into the SymbolRegistry.
//!
//! # Example
//!
//! ```ignore
//! use angelscript_registry::Module;
//!
//! // Create a module in a namespace
//! let module = Module::in_namespace(&["game", "entities"])
//!     .ty::<Player>()
//!     .ty::<Enemy>()
//!     .function(update_world);  // unit struct from #[angelscript::function]
//!
//! // Later, passed to Context for installation
//! context.install(module);
//! ```

use angelscript_core::{
    Any, ClassMeta, FuncdefMeta, FunctionMeta, GlobalPropertyEntry, IntoGlobalProperty,
    InterfaceMeta, TypeHash, TypeSource,
};

/// A module containing pending type and function registrations.
///
/// Modules are namespace-scoped containers that collect metadata from
/// macro-generated code. They are passed to `Context::install()` which
/// handles converting the metadata to registry entries.
///
/// Fields are public for zero-allocation consumption by Context.
#[derive(Debug, Default)]
pub struct Module {
    /// Namespace path for all types in this module.
    pub namespace: Vec<String>,
    /// Pending class registrations.
    pub classes: Vec<ClassMeta>,
    /// Pending function registrations.
    pub functions: Vec<FunctionMeta>,
    /// Pending interface registrations.
    pub interfaces: Vec<InterfaceMeta>,
    /// Pending funcdef registrations.
    pub funcdefs: Vec<FuncdefMeta>,
    /// Pending global property registrations.
    pub globals: Vec<GlobalPropertyEntry>,
}

impl Module {
    /// Create a new empty module at the root namespace.
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a new module in the specified namespace.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let module = Module::in_namespace(&["std", "string"]);
    /// ```
    pub fn in_namespace(namespace: &[&str]) -> Self {
        Self {
            namespace: namespace.iter().map(|s| s.to_string()).collect(),
            ..Default::default()
        }
    }

    /// Get the qualified namespace string (e.g., "std::string").
    pub fn qualified_namespace(&self) -> String {
        self.namespace.join("::")
    }

    // =========================================================================
    // Builder Methods
    // =========================================================================

    /// Register a type using its macro-generated metadata.
    ///
    /// The type must implement `Any` and have a `__as_type_meta()` method
    /// generated by `#[derive(Any)]`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// #[derive(Any)]
    /// struct Player { ... }
    ///
    /// let module = Module::new()
    ///     .ty::<Player>()
    ///     .function(Player::update__meta);
    /// ```
    pub fn ty<T: Any + HasClassMeta>(mut self) -> Self {
        self.classes.push(T::__as_type_meta());
        self
    }


    /// Register a function using its macro-generated metadata.
    ///
    /// Accepts both:
    /// - Unit structs implementing `HasFunctionMeta` (free functions)
    /// - Function pointers `fn() -> FunctionMeta` (methods)
    ///
    /// # Example
    ///
    /// ```ignore
    /// // Free function - unit struct has original name
    /// #[angelscript::function]
    /// fn greet(name: &str) { ... }
    /// let module = Module::new().function(greet);
    ///
    /// // Methods - use __meta suffix
    /// let module = Module::new()
    ///     .ty::<Player>()
    ///     .function(Player::update__meta);
    /// ```
    pub fn function<T: IntoFunctionMeta>(mut self, meta: T) -> Self {
        self.functions.push(meta.into_fn_meta());
        self
    }

    /// Register an interface using its macro-generated metadata.
    ///
    /// # Example
    ///
    /// ```ignore
    /// #[angelscript::interface]
    /// trait Drawable { ... }
    ///
    /// let module = Module::new().interface(__as_Drawable_interface_meta());
    /// ```
    pub fn interface(mut self, meta: InterfaceMeta) -> Self {
        self.interfaces.push(meta);
        self
    }

    /// Register a funcdef using its macro-generated metadata.
    ///
    /// # Example
    ///
    /// ```ignore
    /// #[angelscript::funcdef]
    /// type Callback = fn(i32) -> bool;
    ///
    /// let module = Module::new().funcdef(__as_Callback_funcdef_meta());
    /// ```
    pub fn funcdef(mut self, meta: FuncdefMeta) -> Self {
        self.funcdefs.push(meta);
        self
    }

    /// Register a global property.
    ///
    /// Primitives are registered as constants (immutable).
    /// `Arc<RwLock<T>>` is registered as mutable shared state.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use std::sync::{Arc, RwLock};
    ///
    /// // Primitive constants
    /// let module = Module::new()
    ///     .global("PI", 3.14159f64)      // const double PI
    ///     .global("MAX", 100i32);        // const int MAX
    ///
    /// // Mutable shared state
    /// let score = Arc::new(RwLock::new(0i32));
    /// let module = Module::new()
    ///     .global("score", score);       // int score (mutable)
    /// ```
    pub fn global<V: IntoGlobalProperty>(mut self, name: &str, value: V) -> Self {
        let implementation = value.into_global_impl();
        let data_type = implementation.data_type();
        let is_const = V::is_inherently_const();
        let qualified_name = self.qualify_name(name);

        let entry = GlobalPropertyEntry {
            name: name.to_string(),
            type_hash: TypeHash::from_name(&qualified_name),
            qualified_name,
            data_type,
            is_const,
            source: TypeSource::ffi_untyped(),
            implementation,
        };

        self.globals.push(entry);
        self
    }

    /// Helper to qualify a name with the module's namespace.
    fn qualify_name(&self, name: &str) -> String {
        if self.namespace.is_empty() {
            name.to_string()
        } else {
            format!("{}::{}", self.qualified_namespace(), name)
        }
    }

    /// Check if the module is empty.
    pub fn is_empty(&self) -> bool {
        self.classes.is_empty()
            && self.functions.is_empty()
            && self.interfaces.is_empty()
            && self.funcdefs.is_empty()
            && self.globals.is_empty()
    }

    /// Get the total number of pending registrations.
    pub fn len(&self) -> usize {
        self.classes.len()
            + self.functions.len()
            + self.interfaces.len()
            + self.funcdefs.len()
            + self.globals.len()
    }
}

/// Trait for types that have macro-generated ClassMeta.
///
/// This is implemented by types with `#[derive(Any)]`.
pub trait HasClassMeta {
    /// Get the class metadata for this type.
    fn __as_type_meta() -> ClassMeta;
}

/// Trait for function metadata providers.
///
/// This is implemented by unit structs generated by `#[angelscript::function]`.
/// Pass the unit struct instance to `Module::function()`.
pub trait HasFunctionMeta {
    /// Get the function metadata.
    fn __as_fn_meta() -> FunctionMeta;
}

/// Trait for types that can be converted to function metadata.
///
/// This is implemented for:
/// - Unit structs implementing `HasFunctionMeta` (free functions)
/// - `fn() -> FunctionMeta` (methods - const fn pointer)
/// - `FunctionMeta` directly
pub trait IntoFunctionMeta {
    /// Convert to function metadata.
    fn into_fn_meta(self) -> FunctionMeta;
}

impl<T: HasFunctionMeta> IntoFunctionMeta for T {
    fn into_fn_meta(self) -> FunctionMeta {
        T::__as_fn_meta()
    }
}

impl IntoFunctionMeta for fn() -> FunctionMeta {
    fn into_fn_meta(self) -> FunctionMeta {
        self()
    }
}

impl IntoFunctionMeta for FunctionMeta {
    fn into_fn_meta(self) -> FunctionMeta {
        self
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use angelscript_core::{TypeHash, TypeKind};

    #[test]
    fn new_module_is_empty() {
        let module = Module::new();
        assert!(module.is_empty());
        assert_eq!(module.len(), 0);
        assert!(module.namespace.is_empty());
    }

    #[test]
    fn module_with_namespace() {
        let module = Module::in_namespace(&["std", "string"]);
        assert_eq!(module.namespace, vec!["std", "string"]);
        assert_eq!(module.qualified_namespace(), "std::string");
    }

    #[test]
    fn module_with_class() {
        let mut module = Module::new();
        module.classes.push(ClassMeta {
            name: "Player",
            type_hash: TypeHash::from_name("Player"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec![],
            specialization_of: None,
            specialization_args: vec![],
        });

        assert_eq!(module.len(), 1);
        assert!(!module.is_empty());
        assert_eq!(module.classes.len(), 1);
        assert_eq!(module.classes[0].name, "Player");
    }

    #[test]
    fn module_with_function() {
        let meta = FunctionMeta {
            name: "greet",
            as_name: None,
            params: vec![],
            generic_params: vec![],
            return_meta: Default::default(),
            is_method: false,
            associated_type: None,
            behavior: None,
            is_const: false,
            is_property: false,
            property_name: None,
            is_generic: false,
            list_pattern: None,
            template_params: vec![],
        };

        let mut module = Module::new();
        module.functions.push(meta);
        assert_eq!(module.len(), 1);
        assert_eq!(module.functions.len(), 1);
        assert_eq!(module.functions[0].name, "greet");
    }

    #[test]
    fn module_with_interface() {
        let meta = InterfaceMeta {
            name: "Drawable",
            type_hash: TypeHash::from_name("Drawable"),
            methods: vec![],
        };

        let module = Module::new().interface(meta);
        assert_eq!(module.len(), 1);
        assert_eq!(module.interfaces.len(), 1);
        assert_eq!(module.interfaces[0].name, "Drawable");
    }

    #[test]
    fn module_with_funcdef() {
        let meta = FuncdefMeta {
            name: "Callback",
            type_hash: TypeHash::from_name("Callback"),
            param_types: vec![],
            return_type: TypeHash::from_name("void"),
            parent_type: None,
        };

        let module = Module::new().funcdef(meta);
        assert_eq!(module.len(), 1);
        assert_eq!(module.funcdefs.len(), 1);
        assert_eq!(module.funcdefs[0].name, "Callback");
    }

    #[test]
    fn module_builder_chain() {
        let mut module = Module::in_namespace(&["game"]);

        module.classes.push(ClassMeta {
            name: "Player",
            type_hash: TypeHash::from_name("Player"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec![],
            specialization_of: None,
            specialization_args: vec![],
        });

        module.classes.push(ClassMeta {
            name: "Enemy",
            type_hash: TypeHash::from_name("Enemy"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec![],
            specialization_of: None,
            specialization_args: vec![],
        });

        module.functions.push(FunctionMeta {
            name: "update",
            as_name: None,
            params: vec![],
            generic_params: vec![],
            return_meta: Default::default(),
            is_method: false,
            associated_type: None,
            behavior: None,
            is_const: false,
            is_property: false,
            property_name: None,
            is_generic: false,
            list_pattern: None,
            template_params: vec![],
        });

        assert_eq!(module.qualified_namespace(), "game");
        assert_eq!(module.len(), 3);
        assert_eq!(module.classes.len(), 2);
        assert_eq!(module.functions.len(), 1);
    }

    #[test]
    fn module_direct_field_access() {
        let mut module = Module::in_namespace(&["world"]);

        module.classes.push(ClassMeta {
            name: "Entity",
            type_hash: TypeHash::from_name("Entity"),
            type_kind: TypeKind::reference(),
            properties: vec![],
            template_params: vec![],
            specialization_of: None,
            specialization_args: vec![],
        });

        module.functions.push(FunctionMeta {
            name: "spawn",
            as_name: None,
            params: vec![],
            generic_params: vec![],
            return_meta: Default::default(),
            is_method: false,
            associated_type: None,
            behavior: None,
            is_const: false,
            is_property: false,
            property_name: None,
            is_generic: false,
            list_pattern: None,
            template_params: vec![],
        });

        // Direct field access - zero allocation consumption
        assert_eq!(module.namespace, vec!["world"]);
        assert_eq!(module.classes.len(), 1);
        assert_eq!(module.functions.len(), 1);
        assert!(module.interfaces.is_empty());
        assert!(module.funcdefs.is_empty());
    }

    #[test]
    fn module_with_global_constant() {
        let module = Module::new()
            .global("PI", 3.14159f64)
            .global("MAX_PLAYERS", 64i32);

        assert_eq!(module.len(), 2);
        assert_eq!(module.globals.len(), 2);

        let pi = &module.globals[0];
        assert_eq!(pi.name, "PI");
        assert_eq!(pi.qualified_name, "PI");
        assert!(pi.is_const);

        let max = &module.globals[1];
        assert_eq!(max.name, "MAX_PLAYERS");
        assert!(max.is_const);
    }

    #[test]
    fn module_with_global_in_namespace() {
        let module = Module::in_namespace(&["math"])
            .global("PI", 3.14159f64);

        assert_eq!(module.globals.len(), 1);
        let pi = &module.globals[0];
        assert_eq!(pi.name, "PI");
        assert_eq!(pi.qualified_name, "math::PI");
        assert_eq!(pi.type_hash, TypeHash::from_name("math::PI"));
    }
}
