//! FunctionDef - function definition with complete signature.
//!
//! This module provides `FunctionDef`, which represents a complete function definition
//! including all parameters, return type, and function traits. Unlike the old 3-pass
//! architecture, functions are always registered with complete signatures.
//!
//! # Example
//!
//! ```
//! use angelscript_compiler::types::{FunctionDef, FunctionTraits, Param, DataType, TypeHash, Visibility};
//! use angelscript_compiler::types::primitives;
//!
//! // Create a simple function: int add(int a, int b)
//! let func = FunctionDef {
//!     func_hash: TypeHash::from_function("add", &[primitives::INT32, primitives::INT32]),
//!     name: "add".to_string(),
//!     namespace: vec![],
//!     params: vec![
//!         Param::new("a", DataType::simple(primitives::INT32)),
//!         Param::new("b", DataType::simple(primitives::INT32)),
//!     ],
//!     return_type: DataType::simple(primitives::INT32),
//!     object_type: None,
//!     traits: FunctionTraits::default(),
//!     is_native: false,
//!     visibility: Visibility::Public,
//! };
//! assert_eq!(func.name, "add");
//! assert_eq!(func.params.len(), 2);
//! ```

use std::fmt;

use super::{DataType, TypeHash};
use super::type_def::Visibility;

/// Function parameter with name, type, and optional default value marker.
///
/// Note: Unlike the main crate's `ScriptParam<'ast>`, this struct uses owned types
/// and does not store the default value expression. Default values are handled
/// during compilation, not stored in the definition.
#[derive(Debug, Clone, PartialEq)]
pub struct Param {
    /// Parameter name.
    pub name: String,
    /// Parameter type.
    pub data_type: DataType,
    /// Whether this parameter has a default value.
    /// The actual default expression is evaluated during compilation.
    pub has_default: bool,
}

impl Param {
    /// Create a new parameter without a default value.
    pub fn new(name: impl Into<String>, data_type: DataType) -> Self {
        Self {
            name: name.into(),
            data_type,
            has_default: false,
        }
    }

    /// Create a new parameter with a default value.
    pub fn with_default(name: impl Into<String>, data_type: DataType) -> Self {
        Self {
            name: name.into(),
            data_type,
            has_default: true,
        }
    }
}

impl fmt::Display for Param {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} {}", self.data_type, self.name)?;
        if self.has_default {
            write!(f, " = ...")?;
        }
        Ok(())
    }
}

/// Type of auto-generated method (constructors and operators).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AutoGeneratedMethod {
    /// Auto-generated default constructor: `ClassName()`
    DefaultConstructor,
    /// Auto-generated copy constructor: `ClassName(const ClassName &in)`
    CopyConstructor,
    /// Auto-generated assignment operator: `ClassName& opAssign(const ClassName &in)`
    OpAssign,
}

/// Function traits (special function behaviors).
///
/// These flags indicate special properties of a function such as whether it's
/// a constructor, destructor, virtual method, etc.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct FunctionTraits {
    /// This is a constructor.
    pub is_constructor: bool,
    /// This is a destructor.
    pub is_destructor: bool,
    /// This function is final (cannot be overridden).
    pub is_final: bool,
    /// This function is virtual (can be overridden).
    pub is_virtual: bool,
    /// This function is abstract (must be overridden).
    pub is_abstract: bool,
    /// This function is const (doesn't modify object state).
    pub is_const: bool,
    /// This constructor is explicit (cannot be used for implicit conversions).
    pub is_explicit: bool,
    /// If this is an auto-generated method, specifies which type.
    pub auto_generated: Option<AutoGeneratedMethod>,
}

impl FunctionTraits {
    /// Create default function traits (no special behaviors).
    pub const fn new() -> Self {
        Self {
            is_constructor: false,
            is_destructor: false,
            is_final: false,
            is_virtual: false,
            is_abstract: false,
            is_const: false,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Create traits for a constructor.
    pub const fn constructor() -> Self {
        Self {
            is_constructor: true,
            is_destructor: false,
            is_final: false,
            is_virtual: false,
            is_abstract: false,
            is_const: false,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Create traits for a destructor.
    pub const fn destructor() -> Self {
        Self {
            is_constructor: false,
            is_destructor: true,
            is_final: false,
            is_virtual: false,
            is_abstract: false,
            is_const: false,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Create traits for a const method.
    pub const fn const_method() -> Self {
        Self {
            is_constructor: false,
            is_destructor: false,
            is_final: false,
            is_virtual: false,
            is_abstract: false,
            is_const: true,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Create traits for a virtual method.
    pub const fn virtual_method() -> Self {
        Self {
            is_constructor: false,
            is_destructor: false,
            is_final: false,
            is_virtual: true,
            is_abstract: false,
            is_const: false,
            is_explicit: false,
            auto_generated: None,
        }
    }

    /// Set the auto-generated type.
    pub const fn with_auto_generated(mut self, auto: AutoGeneratedMethod) -> Self {
        self.auto_generated = Some(auto);
        self
    }
}

/// Function definition with complete signature.
///
/// In the 2-pass compiler architecture, functions are always registered with
/// complete signatures. There is no `signature_filled` field because functions
/// are never in an incomplete state.
#[derive(Debug, Clone, PartialEq)]
pub struct FunctionDef {
    /// Deterministic hash for identity - computed from qualified name and parameter types.
    pub func_hash: TypeHash,
    /// Function name (unqualified).
    pub name: String,
    /// Namespace path (e.g., `["Game", "Player"]`).
    pub namespace: Vec<String>,
    /// Parameters with types.
    pub params: Vec<Param>,
    /// Return type.
    pub return_type: DataType,
    /// Object type if this is a method.
    pub object_type: Option<TypeHash>,
    /// Function traits (virtual, const, etc.).
    pub traits: FunctionTraits,
    /// True if this is a native (FFI) function.
    pub is_native: bool,
    /// Visibility (public, private, protected) - only meaningful for methods.
    pub visibility: Visibility,
}

impl FunctionDef {
    /// Get the qualified name of this function.
    ///
    /// # Example
    ///
    /// ```
    /// use angelscript_compiler::types::{FunctionDef, FunctionTraits, DataType, TypeHash, Visibility};
    ///
    /// let func = FunctionDef {
    ///     func_hash: TypeHash::from_name("Game::Player::update"),
    ///     name: "update".to_string(),
    ///     namespace: vec!["Game".to_string(), "Player".to_string()],
    ///     params: vec![],
    ///     return_type: DataType::void(),
    ///     object_type: None,
    ///     traits: FunctionTraits::default(),
    ///     is_native: false,
    ///     visibility: Visibility::Public,
    /// };
    /// assert_eq!(func.qualified_name(), "Game::Player::update");
    /// ```
    pub fn qualified_name(&self) -> String {
        if self.namespace.is_empty() {
            self.name.clone()
        } else {
            format!("{}::{}", self.namespace.join("::"), self.name)
        }
    }

    /// Check if this function is a method (belongs to an object type).
    pub fn is_method(&self) -> bool {
        self.object_type.is_some()
    }

    /// Check if this function is a constructor.
    pub fn is_constructor(&self) -> bool {
        self.traits.is_constructor
    }

    /// Check if this function is a destructor.
    pub fn is_destructor(&self) -> bool {
        self.traits.is_destructor
    }

    /// Check if this function is const.
    pub fn is_const(&self) -> bool {
        self.traits.is_const
    }

    /// Check if this function is virtual.
    pub fn is_virtual(&self) -> bool {
        self.traits.is_virtual
    }

    /// Check if this function is abstract.
    pub fn is_abstract(&self) -> bool {
        self.traits.is_abstract
    }

    /// Check if this function is final.
    pub fn is_final(&self) -> bool {
        self.traits.is_final
    }

    /// Get the number of required parameters (those without defaults).
    pub fn required_param_count(&self) -> usize {
        self.params.iter().filter(|p| !p.has_default).count()
    }
}

impl fmt::Display for FunctionDef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Format: [visibility] [traits] return_type name(params)
        // Example: "public virtual void update(float dt)"

        if self.visibility != Visibility::Public {
            write!(f, "{} ", self.visibility)?;
        }

        if self.traits.is_virtual {
            write!(f, "virtual ")?;
        }
        if self.traits.is_final {
            write!(f, "final ")?;
        }
        if self.traits.is_abstract {
            write!(f, "abstract ")?;
        }

        write!(f, "{} {}(", self.return_type, self.name)?;

        for (i, param) in self.params.iter().enumerate() {
            if i > 0 {
                write!(f, ", ")?;
            }
            write!(f, "{}", param)?;
        }

        write!(f, ")")?;

        if self.traits.is_const {
            write!(f, " const")?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::primitives;

    #[test]
    fn param_creation() {
        let param = Param::new("x", DataType::simple(primitives::INT32));
        assert_eq!(param.name, "x");
        assert!(!param.has_default);

        let param_default = Param::with_default("y", DataType::simple(primitives::FLOAT));
        assert_eq!(param_default.name, "y");
        assert!(param_default.has_default);
    }

    #[test]
    fn param_display() {
        let param = Param::new("x", DataType::simple(primitives::INT32));
        let s = format!("{}", param);
        assert!(s.contains("x"));

        let param_default = Param::with_default("y", DataType::simple(primitives::INT32));
        let s = format!("{}", param_default);
        assert!(s.contains("= ..."));
    }

    #[test]
    fn function_traits_default() {
        let traits = FunctionTraits::default();
        assert!(!traits.is_constructor);
        assert!(!traits.is_destructor);
        assert!(!traits.is_virtual);
        assert!(!traits.is_const);
        assert!(!traits.is_final);
        assert!(!traits.is_abstract);
        assert!(!traits.is_explicit);
        assert!(traits.auto_generated.is_none());
    }

    #[test]
    fn function_traits_constructor() {
        let traits = FunctionTraits::constructor();
        assert!(traits.is_constructor);
        assert!(!traits.is_destructor);
    }

    #[test]
    fn function_traits_destructor() {
        let traits = FunctionTraits::destructor();
        assert!(traits.is_destructor);
        assert!(!traits.is_constructor);
    }

    #[test]
    fn function_traits_const_method() {
        let traits = FunctionTraits::const_method();
        assert!(traits.is_const);
    }

    #[test]
    fn function_traits_virtual_method() {
        let traits = FunctionTraits::virtual_method();
        assert!(traits.is_virtual);
    }

    #[test]
    fn function_traits_with_auto_generated() {
        let traits = FunctionTraits::constructor()
            .with_auto_generated(AutoGeneratedMethod::DefaultConstructor);
        assert!(traits.is_constructor);
        assert_eq!(traits.auto_generated, Some(AutoGeneratedMethod::DefaultConstructor));
    }

    #[test]
    fn function_def_creation() {
        let func = FunctionDef {
            func_hash: TypeHash::from_function("add", &[primitives::INT32, primitives::INT32]),
            name: "add".to_string(),
            namespace: vec![],
            params: vec![
                Param::new("a", DataType::simple(primitives::INT32)),
                Param::new("b", DataType::simple(primitives::INT32)),
            ],
            return_type: DataType::simple(primitives::INT32),
            object_type: None,
            traits: FunctionTraits::default(),
            is_native: false,
            visibility: Visibility::Public,
        };
        assert_eq!(func.name, "add");
        assert_eq!(func.params.len(), 2);
        assert!(!func.is_method());
    }

    #[test]
    fn function_def_qualified_name() {
        let func = FunctionDef {
            func_hash: TypeHash::from_name("Game::update"),
            name: "update".to_string(),
            namespace: vec!["Game".to_string()],
            params: vec![],
            return_type: DataType::void(),
            object_type: None,
            traits: FunctionTraits::default(),
            is_native: false,
            visibility: Visibility::Public,
        };
        assert_eq!(func.qualified_name(), "Game::update");
    }

    #[test]
    fn function_def_method() {
        let player_hash = TypeHash::from_name("Player");
        let func = FunctionDef {
            func_hash: TypeHash::from_name("Player::update"),
            name: "update".to_string(),
            namespace: vec![],
            params: vec![Param::new("dt", DataType::simple(primitives::FLOAT))],
            return_type: DataType::void(),
            object_type: Some(player_hash),
            traits: FunctionTraits::virtual_method(),
            is_native: false,
            visibility: Visibility::Public,
        };
        assert!(func.is_method());
        assert!(func.is_virtual());
        assert!(!func.is_const());
    }

    #[test]
    fn function_def_constructor() {
        let player_hash = TypeHash::from_name("Player");
        let func = FunctionDef {
            func_hash: TypeHash::from_name("Player::Player"),
            name: "Player".to_string(),
            namespace: vec![],
            params: vec![],
            return_type: DataType::void(),
            object_type: Some(player_hash),
            traits: FunctionTraits::constructor(),
            is_native: false,
            visibility: Visibility::Public,
        };
        assert!(func.is_constructor());
        assert!(func.is_method());
    }

    #[test]
    fn function_def_required_param_count() {
        let func = FunctionDef {
            func_hash: TypeHash::from_name("test"),
            name: "test".to_string(),
            namespace: vec![],
            params: vec![
                Param::new("a", DataType::simple(primitives::INT32)),
                Param::new("b", DataType::simple(primitives::INT32)),
                Param::with_default("c", DataType::simple(primitives::INT32)),
            ],
            return_type: DataType::void(),
            object_type: None,
            traits: FunctionTraits::default(),
            is_native: false,
            visibility: Visibility::Public,
        };
        assert_eq!(func.params.len(), 3);
        assert_eq!(func.required_param_count(), 2);
    }

    #[test]
    fn function_def_display() {
        let func = FunctionDef {
            func_hash: TypeHash::from_name("update"),
            name: "update".to_string(),
            namespace: vec![],
            params: vec![Param::new("dt", DataType::simple(primitives::FLOAT))],
            return_type: DataType::void(),
            object_type: None,
            traits: FunctionTraits::const_method(),
            is_native: false,
            visibility: Visibility::Public,
        };
        let s = format!("{}", func);
        assert!(s.contains("update"));
        assert!(s.contains("const"));
    }

    #[test]
    fn auto_generated_method_variants() {
        assert_ne!(
            AutoGeneratedMethod::DefaultConstructor,
            AutoGeneratedMethod::CopyConstructor
        );
        assert_ne!(
            AutoGeneratedMethod::CopyConstructor,
            AutoGeneratedMethod::OpAssign
        );
    }
}
